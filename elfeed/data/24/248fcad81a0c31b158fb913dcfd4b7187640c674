<p>The EMRFS S3-optimized committer is a new output committer available for use with&nbsp;<a href="https://aws.amazon.com/big-data/what-is-spark/" target="_blank" rel="noopener">Apache Spark</a> jobs as of <a href="https://aws.amazon.com/emr/" target="_blank" rel="noopener">Amazon EMR</a> 5.19.0. This committer improves performance when writing Apache Parquet files to <a href="https://aws.amazon.com/s3/" target="_blank" rel="noopener">Amazon S3</a> using the <a href="https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-fs.html" target="_blank" rel="noopener">EMR File System (EMRFS)</a>. In this post, we run a performance benchmark to compare this new optimized committer with existing committer algorithms, namely FileOutputCommitter algorithm versions 1 and 2. We close with a discussion on current limitations for the new committer, providing workarounds where possible.</p> 
<h2>Comparison with FileOutputCommitter</h2> 
<p>In Amazon EMR version 5.19.0 and earlier, Spark jobs that write Parquet to Amazon S3 use a Hadoop commit algorithm called FileOutputCommitter by default. There are two versions of this algorithm, version 1 and 2. Both versions rely on writing intermediate task output to temporary locations. They subsequently perform rename operations to make the data visible at task or job completion time.</p> 
<p>Algorithm version 1 has two phases of rename: one to commit the individual task output, and the other to commit the overall job output from completed/successful tasks. Algorithm version 2 is more efficient because task commits rename files directly to the final output location. This eliminates the second rename phase, but it makes partial data visible before the job completes, which not all workloads can tolerate.</p> 
<p>The renames that are performed are fast, metadata-only operations on the Hadoop Distributed File System (HDFS). However, when output is written to object stores such as Amazon S3, renames are implemented by copying data to the target and then deleting the source. This rename “penalty” is exacerbated with directory renames, which can happen in both phases of FileOutputCommitter v1. Whereas these are single metadata-only operations on HDFS, committers must execute <em>N</em> copy-and-delete operations on S3.</p> 
<p>To partially mitigate this, Amazon EMR 5.14.0+ defaults to FileOutputCommitter v2 when writing Parquet data to S3 with EMRFS in Spark. The new EMRFS S3-optimized committer improves on that work to avoid rename operations altogether by using the transactional properties of <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/mpuoverview.html" target="_blank" rel="noopener">Amazon S3 multipart uploads</a>. Tasks may then write their data directly to the final output location, but defer completion of each output file until task commit time.</p> 
<h3>Performance test</h3> 
<p>We evaluated the write performance of the different committers by executing the following <code>INSERT OVERWRITE</code> Spark SQL query. The <code>SELECT * FROM range(…) </code>clause generated data at execution time. This produced ~15 GB of data across exactly 100 Parquet files in Amazon S3.</p> 
<div class="hide-language"> 
 <pre><code class="lang-sql">SET rows=4e9; -- 4 Billion
SET partitions=100;

INSERT OVERWRITE DIRECTORY ‘s3://${bucket}/perf-test/${trial_id}’
USING PARQUET SELECT * FROM range(0, ${rows}, 1, ${partitions});</code></pre> 
</div> 
<p><strong>Note:</strong> The EMR cluster ran in the same AWS Region as the S3 <code>bucket</code>. The <code>trial_id</code> property used a UUID generator to ensure that there was no conflict between test runs.</p> 
<p>We executed our test on an EMR cluster created with the emr-5.19.0 release label, with a single m5d.2xlarge instance in the master group, and eight m5d.2xlarge instances in the core group. We used the default Spark configuration properties set by Amazon EMR for this cluster configuration, which include the following:</p> 
<div class="hide-language"> 
 <pre><code class="lang-code">spark.dynamicAllocation.enabled true
spark.executor.memory 11168M
spark.executor.cores 4</code></pre> 
</div> 
<p>After running 10 trials for each committer, we captured and summarized query execution times in the following chart. Whereas FileOutputCommitter v2 averaged 49 seconds, the EMRFS S3-optimized committer averaged only 31 seconds—a 1.6x speedup.</p> 
<p><img class="alignnone size-full wp-image-6237" style="margin: 20px 0px 20px 0px;border: 1px solid #cccccc" src="https://d2908q01vomqb2.cloudfront.net/b6692ea5df920cad691c20319a6fffd7a4a766b8/2018/12/28/ApacheEMRFS1.png" alt="" width="800" height="399" /></p> 
<p>As mentioned earlier, FileOutputCommitter v2 eliminates some, but not all, rename operations that FileOutputCommitter v1 uses. To illustrate the full performance impact of renames against S3, we reran the test using FileOutputCommitter v1. In this scenario, we observed an average runtime of 450 seconds, which is 14.5x slower than the EMRFS S3-optimized committer.</p> 
<p><img class="alignnone size-full wp-image-6238" style="margin: 20px 0px 20px 0px;border: 1px solid #cccccc" src="https://d2908q01vomqb2.cloudfront.net/b6692ea5df920cad691c20319a6fffd7a4a766b8/2018/12/28/ApacheEMRFS2.png" alt="" width="800" height="401" /></p> 
<p>The last scenario we evaluated is the case when <a href="https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-plan-consistent-view.html" target="_blank" rel="noopener">EMRFS consistent view</a> is enabled, which addresses issues that can arise due to the Amazon S3 data consistency model. In this mode, the EMRFS S3-optimized committer time was unaffected by this change and still averaged 30 seconds. On the other hand, FileOutputCommitter v2 averaged 53 seconds, which was slower than when the consistent view feature was turned off, widening the overall performance difference to 1.8x.</p> 
<p><img class="alignnone size-full wp-image-6239" style="margin: 20px 0px 20px 0px;border: 1px solid #cccccc" src="https://d2908q01vomqb2.cloudfront.net/b6692ea5df920cad691c20319a6fffd7a4a766b8/2018/12/28/ApacheEMRFS3.png" alt="" width="800" height="413" /></p> 
<h2>Job correctness</h2> 
<p>The EMRFS S3-optimized committer has the same limitations that FileOutputCommitter v2 has because both improve performance by fully delegating commit responsibilities to the individual tasks. The following is a discussion of the notable consequences of this design choice.</p> 
<h3>Partial results from incomplete or failed jobs</h3> 
<p>Because both committers have their tasks write to the final output location, concurrent readers of that output location can view partial results when using either of them. If a job fails, partial results are left behind from any tasks that have committed before the overall job failed. This situation can lead to duplicate output if the job is run again without first cleaning up the output location.</p> 
<p>One way to mitigate this issue is to ensure that a job uses a different output location each time it runs, publishing the location to downstream readers only if the job succeeds. The following code block is an example of this strategy for workloads that use Hive tables. Notice how <code>output_location</code> is set to a unique value each time the job is run, and that the table partition is registered only if the rest of the query succeeds. As long as readers exclusively access data via the table abstraction, they cannot see results before the job finishes.</p> 
<div class="hide-language"> 
 <pre><code class="lang-sql">SET attempt_id=&lt;a random UUID&gt;;
SET output_location=s3://bucket/${attempt_id};

INSERT OVERWRITE DIRECTORY ‘${output_location}’
USING PARQUET SELECT * FROM input;

ALTER TABLE output ADD PARTITION (dt = ‘2018-11-26’)
LOCATION ‘${output_location}’;
</code></pre> 
</div> 
<p>This approach requires treating the locations that partitions point to as immutable. Updates to partition contents require restating all results into a new location in S3, and then updating the partition metadata to point to that new location.</p> 
<h3>Duplicate results from non-idempotent tasks</h3> 
<p>Another scenario that can cause both committers to produce incorrect results is when jobs composed of non-idempotent tasks produce outputs into non-deterministic locations for each task attempt.</p> 
<p>The following is an example of a query that illustrates the issue. It uses a timestamp-based table partitioning scheme to ensure that it writes to a different location for each task attempt.</p> 
<div class="hide-language"> 
 <pre><code class="lang-sql">SET hive.exec.dynamic.partition=true
SET hive.exec.dynamic.partition.mode=nonstrict;

INSERT INTO data PARTITION (time) SELECT 42, current_timestamp();</code></pre> 
</div> 
<p>You can avoid the issue of duplicate results in this scenario by ensuring that tasks write to a consistent location across task attempts. For example, instead of calling functions that return the current timestamp within tasks, consider providing the current timestamp as an input to the job. Similarly, if a random number generator is used within jobs, consider using a fixed seed or one that is based on the task’s partition number to ensure that task reattempts uses the same value.</p> 
<p><strong>Note:</strong> Spark’s built-in random functions <code>rand()</code>, <code>randn()</code>, and <code>uuid()</code> are already designed with this in mind.</p> 
<h2>Enabling the EMRFS S3-optimized committer</h2> 
<p>Starting with Amazon EMR version 5.20.0, the EMRFS S3-optimized committer is&nbsp;enabled by default. In Amazon EMR version 5.19.0, you can enable the committer by setting the&nbsp;<code>spark.sql.parquet.fs.optimized.committer.optimization-enabled</code> property to <code>true</code>&nbsp;from within Spark or when creating clusters. The committer takes effect when you use Spark’s built-in Parquet support to write Parquet files into Amazon S3 with EMRFS. This includes using the Parquet data source with Spark SQL, DataFrames, or Datasets. However, there are some use cases when the EMRFS S3-optimized committer does not take effect, and some use cases where Spark performs its own renames entirely outside of the committer. For more information about the committer and about these special cases, see <a href="https://docs.aws.amazon.com/emr/latest/ReleaseGuide/emr-spark-s3-optimized-committer.html" target="_blank" rel="noopener">Using the&nbsp;EMRFS S3-optimized Committer</a> in the <em>Amazon EMR Release Guide</em>.</p> 
<h2>Related Work – S3A Committers</h2> 
<p>The EMRFS S3-optimized committer was inspired by concepts used by <a href="https://hadoop.apache.org/docs/r3.1.1/hadoop-aws/tools/hadoop-aws/committers.html#Meet_the_S3A_Commmitters" target="_blank" rel="noopener">committers that support the S3A file system</a>. The key take-away is that these committers use the transactional nature of S3 multipart uploads to eliminate some or all of the rename costs. This is also the core concept used by the EMRFS S3-optimized committer.</p> 
<p>For more information about the various committers available within the ecosystem, including those that support the S3A file system, see the official <a href="https://hadoop.apache.org/docs/r3.2.0/hadoop-aws/tools/hadoop-aws/committer_architecture.html" target="_blank" rel="noopener">Apache Hadoop documentation</a>.</p> 
<h2>Summary</h2> 
<p>The EMRFS S3-optimized committer improves write performance compared to FileOutputCommitter. Starting with Amazon EMR version 5.19.0, you can use it with Spark’s built-in Parquet support. For more information, see <a href="https://docs.aws.amazon.com/emr/latest/ReleaseGuide/emr-spark-s3-optimized-committer.html" target="_blank" rel="noopener">Using the&nbsp;EMRFS S3-optimized Committer</a> in the <em>Amazon EMR Release Guide</em>.</p> 
<p>&nbsp;</p> 
<hr /> 
<h3>About the authors</h3> 
<p><strong><img class="size-full wp-image-6240 alignleft" src="https://d2908q01vomqb2.cloudfront.net/b6692ea5df920cad691c20319a6fffd7a4a766b8/2018/12/28/petersla.png" alt="" width="113" height="164" />Peter Slawski is a software development engineer with Amazon Web Services.<br /> </strong></p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p><strong><img class="size-full wp-image-6241 alignleft" src="https://d2908q01vomqb2.cloudfront.net/b6692ea5df920cad691c20319a6fffd7a4a766b8/2018/12/28/jonathak.png" alt="" width="113" height="155" />Jonathan Kelly is a senior software development engineer with Amazon Web Services.</strong></p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p>