<p><img class="size-full wp-image-6877 alignright" src="https://d2908q01vomqb2.cloudfront.net/b6692ea5df920cad691c20319a6fffd7a4a766b8/2019/05/02/QueryServiceLogsAthena1.png" alt="" width="250" height="176" />Many organizations use <u><a href="https://aws.amazon.com/s3/" target="_blank" rel="noopener">Amazon Simple Storage Service (Amazon S3)</a></u> as a primary storage destination for a wide variety of logs including AWS service logs. One of the benefits of storing log data in Amazon S3 is that you can access it in any number of ways. One popular option is to query it using <u><a href="https://aws.amazon.com/athena/" target="_blank" rel="noopener">Amazon Athena</a></u>, a serverless query engine for data on S3. Common use cases for querying logs are service and application troubleshooting, performance analysis, and security audits. To get the best performance and reduce query costs in Athena, we recommend following common best practices, as outlined in <a href="https://aws.amazon.com/blogs/big-data/top-10-performance-tuning-tips-for-amazon-athena/" target="_blank" rel="noopener">Top 10 Performance Tuning Tips for Amazon Athena</a> on the AWS Big Data Blog. These best practices include converting the data to a columnar format like <u><a href="https://parquet.apache.org/" target="_blank" rel="noopener">Apache Parquet</a></u> and partitioning the resulting data in S3.</p> 
<p>In this post, we’re open-sourcing a Python library known as Athena Glue Service Logs (AGSlogger). This library has predefined templates for parsing and optimizing the most popular log formats. The library provides a mechanism for defining schemas, managing partitions, and transforming data within an extract, transform, load (ETL) job in <u><a href="https://aws.amazon.com/glue/" target="_blank" rel="noopener">AWS Glue</a></u>. AWS Glue is a serverless data transformation and cataloging service. You can use this library in conjunction with AWS Glue ETL jobs to enable a common framework for processing log data.<span id="more-6865"></span></p> 
<h2>Using Python libraries with AWS Glue ETL</h2> 
<p>One of the features of AWS Glue ETL is the ability to <u><a href="https://docs.aws.amazon.com/glue/latest/dg/aws-glue-programming-python-libraries.html" target="_blank" rel="noopener">import Python libraries</a></u> into a job (as described in the documentation). We take advantage of this feature in our approach. With this capability, you first provide a link to a .zip file in Amazon S3 containing selected Python modules to AWS Glue. Then AWS Glue imports them at runtime.</p> 
<p>We want our AWS Glue jobs to be as simple as possible while enabling the ability to easily roll out new versions of the library. To accomplish this, all of the setup, configuration, and transformation logic is contained in the library and AWS Glue simply executes the job. As new log formats are added or updated in the library, a new version of the .zip file can be deployed to S3. It’s then automatically imported by the relevant AWS Glue job. Here is an example ETL script:</p> 
<div class="hide-language"> 
 <pre><code class="lang-python">from athena_glue_service_logs.job import JobRunner
&nbsp;
job_run = JobRunner(service_name='s3_access')
job_run.convert_and_partition()</code></pre> 
</div> 
<h2>About the AGSlogger library</h2> 
<p>The library is available on GitHub in the <a href="https://github.com/awslabs/athena-glue-service-logs" target="_blank" rel="noopener">athena-glue-service-logs</a> repository. It’s designed to do an initial conversion of AWS Service logs and also perform ongoing conversion as new logs are delivered to S3. The following log types are supported:</p> 
<ul> 
 <li>Application Load Balancer</li> 
 <li>Classic Load Balancer</li> 
 <li>AWS CloudTrail</li> 
 <li>Amazon CloudFront</li> 
 <li>S3 Access</li> 
 <li>Amazon VPC Flow</li> 
</ul> 
<p>To convert additional logs, update the <tt>service_name</tt> variable in the script, and also the different job parameters that point to your desired table names and Amazon S3 locations.</p> 
<p>There are some limitations of the script:</p> 
<ul> 
 <li>The script has not been tested with large volumes of log data (greater than 100 GiB).</li> 
 <li>If you have a large number of log files, you might need to increase your Apache Spark executor settings. Edit the AWS Glue job and add the following job parameter:</li> 
</ul> 
<p style="padding-left: 60px"><tt>key: --conf<br /> value: spark.yarn.executor.memoryOverhead=1G</tt></p> 
<ul> 
 <li>If you do not have any recent logs (less than 30 days old) for certain log types like S3 Access, the script may not be able to properly populate the optimized table.</li> 
 <li>Several CloudTrail fields such as <tt>requestParameters</tt> and <tt>responseElements</tt> are left as JSON strings – you can use Athena to <a href="https://docs.aws.amazon.com/athena/latest/ug/extracting-data-from-JSON.html" target="_blank" rel="noopener">extract data from this JSON</a> at the time of query.</li> 
</ul> 
<h2>Before you begin</h2> 
<p>There are a few prerequisites before you get started:</p> 
<ol> 
 <li>Create an IAM role to use with AWS Glue. For more information, see <u><a href="http://docs.aws.amazon.com/glue/latest/dg/create-an-iam-role.html?icmpid=docs_glue_console" target="_blank" rel="noopener">Create an IAM Role for AWS Glue</a></u> in the AWS Glue documentation.</li> 
 <li>Ensure that you have access to Athena from your account.</li> 
 <li>We use <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ServerLogs.html" target="_blank" rel="noopener">Amazon S3 server access logs</a> as our example for this script, so enable access logging on an Amazon S3 bucket. For more information, see <u><a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ServerLogs.html#server-access-logging-overview" target="_blank" rel="noopener">How to Enable Server Access Logging</a> </u>in the<br /> S3 documentation.</li> 
 <li>Download and store the Python library in an Amazon S3 bucket in the same AWS Region in which you run the AWS Glue ETL job. Download the latest release from <u><a href="https://github.com/awslabs/athena-glue-service-logs/releases" target="_blank" rel="noopener">https://github.com/awslabs/athena-glue-service-logs/releases</a></u>. Then, copy the .zip file to your Amazon S3 bucket, as follows:</li> 
</ol> 
<p style="padding-left: 60px"><tt>aws s3 cp athena_glue_converter_v5.3.0.zip s3://&lt;bucket&gt;/glue_scripts/</tt></p> 
<p>Now, you are ready to create the AWS Glue ETL job.</p> 
<p><strong>Create an AWS Glue ETL job using the library</strong></p> 
<p>For this post, we focus on <a href="https://docs.aws.amazon.com/AmazonS3/latest/dev/ServerLogs.html" target="_blank" rel="noopener">Amazon S3 server access logs</a>. (described in the documentation). By default, these logs are delivered to a single location in Amazon S3. Converting to Parquet and partitioning these logs can significantly improve query performance and decrease query costs.</p> 
<p>If you’ve cloned the repository associated with this release, you can use a “make” command to automate the job creation. We also walk through the job creation process in the AWS Glue console. There are a few specific settings on the <strong>Job properties</strong> page we need to set.</p> 
<h3>To create the AWS Glue ETL job</h3> 
<ol> 
 <li>In the AWS Glue console, choose <strong>Jobs</strong> under <strong>ETL</strong> on the navigation pane, and then choose <strong>Add Job</strong>. Follow the job creation wizard. Ensure that “A new script to be authored by you” is selected. We provide the code for it later. Our ETL language is Python. Under advanced properties, enable the <strong>Job bookmark</strong>. Job metrics can also be useful when monitoring your job, but not required.</li> 
 <li>Under <strong>Script libraries</strong> in the <strong>Python library path</strong> section, put the full path to the .zip file that you uploaded to your Amazon S3 bucket as shown previously:<br /> <tt>s3://&lt;bucket&gt;/glue_scripts/athena_glue_converter_v5.3.0.zip<br /> </tt><br /> You can adjust the DPUs if you think you need more or less processing power. For our purposes, you can leave it at 10.</li> 
</ol> 
<ol start="3"> 
 <li>Specify a few different types of parameters, described in detail following:</li> 
</ol> 
<ul> 
 <li>The source of your Amazon S3 Server Access Logs.</li> 
 <li>The destination where to save the converted logs.</li> 
</ul> 
<p>AWS service logs can be stored in a number of different locations, as discussed in <u><a href="https://github.com/awslabs/athena-glue-service-logs#service-log-specifics" target="_blank" rel="noopener">Service Log Specifics</a></u>. For storing Amazon S3 server access logs, specify the bucket and prefix matching those that you configured on the S3 bucket where you enabled access logging.</p> 
<ul> 
 <li>The names of the databases and tables that are created in the AWS Glue Data Catalog.</li> 
</ul> 
<p>By default, the converted logs are partitioned by date. The script creates the necessary tables and keeps the partitions up-to-date on subsequent runs of the job. You don’t need to use AWS Glue crawlers, although they can provide similar functionality. Here are the different properties you need to configure:</p> 
<table border="1" cellpadding="10"> 
 <tbody> 
  <tr style="background-color: #000000"> 
   <td style="text-align: center" width="225"><strong><span style="color: #ffffff">Key</span></strong></td> 
   <td style="text-align: center" width="288"><strong><span style="color: #ffffff">Value</span></strong></td> 
  </tr> 
  <tr> 
   <td width="225"><tt>--raw_database_name</tt></td> 
   <td width="288"><tt>source_logs</tt></td> 
  </tr> 
  <tr> 
   <td width="225"><tt>--raw_table_name</tt></td> 
   <td width="288"><tt>s3_access</tt></td> 
  </tr> 
  <tr> 
   <td width="225"><tt>--converted_database_name</tt></td> 
   <td width="288"><tt>aws_service_logs</tt></td> 
  </tr> 
  <tr> 
   <td width="225"><tt>--converted_table_name</tt></td> 
   <td width="288"><tt>s3_access</tt></td> 
  </tr> 
  <tr> 
   <td width="225"><tt>--s3_converted_target</tt></td> 
   <td width="288"><tt>s3://&lt;bucket&gt;/converted/s3_access</tt></td> 
  </tr> 
  <tr> 
   <td width="225"><tt>--s3_source_location</tt></td> 
   <td width="288"> <p><tt>s3://&lt;bucket&gt;/s3_access</tt></p> <p>&nbsp;</p></td> 
  </tr> 
 </tbody> 
</table> 
<ol start="4"> 
 <li>Continue with the rest of the wizard, finishing the job creation flow. The script editor opens. Replace all the code in the script editor, even the import lines, with these lines: 
  <div class="hide-language"> 
   <pre><code class="lang-python">from athena_glue_service_logs.job import JobRunner
&nbsp;
job_run = JobRunner(service_name='s3_access')
job_run.convert_and_partition()</code></pre> 
  </div> </li> 
</ol> 
<ol start="5"> 
 <li>Save the script and choose <strong>Run Job</strong>! When the job begins, you see log output from the job scrolling under the script.</li> 
</ol> 
<p>The script you just created is saved to S3 in a standard bucket. You can also use the AWS Command Line Interface to create the AWS Glue ETL job. Copy the script preceding to S3 first and provide that as the <tt>ScriptLocation</tt> parameter.</p> 
<div class="hide-language"> 
 <pre><code class="lang-code">aws glue create-job --name S3AccessLogConvertor \
--description &quot;Convert and partition S3 Access logs&quot; \
--role AWSGlueServiceRoleDefault \
--command Name=glueetl,ScriptLocation=s3://&lt;bucket&gt;/glue_scripts/s3_access_job.py \
--default-arguments '{
  &quot;--extra-py-files&quot;:&quot;s3://&lt;bucket&gt;/glue_scripts/athena_glue_converter_v5.3.0.zip&quot;,
  &quot;--job-bookmark-option&quot;:&quot;job-bookmark-enable&quot;,
  &quot;--raw_database_name&quot;:&quot;source_logs&quot;,
  &quot;--raw_table_name&quot;:&quot;s3_access&quot;,
  &quot;--converted_database_name&quot;:&quot;aws_service_logs&quot;,
  &quot;--converted_table_name&quot;:&quot;s3_access&quot;,
  &quot;--TempDir&quot;:&quot;s3://&lt;bucket&gt;/tmp&quot;,
  &quot;--s3_converted_target&quot;:&quot;s3://&lt;bucket&gt;/converted/s3_access&quot;,
  &quot;--s3_source_location&quot;:&quot;s3://&lt;bucket&gt;/s3_access/&quot;
}'</code></pre> 
</div> 
<h2>Scheduling future runs</h2> 
<p>By default, this job is configured to run on a manual basis. To run it on a regular basis, set up a new schedule trigger in AWS Glue to run the job at your desired frequency. We recommend scheduling it at hourly to make it easier to locate recent logs for your optimized queries.</p> 
<p>On every run of the job, the script looks for the new log data and converts it to Parquet format. The script then adds any new partitions that might have been added as a result of the conversion. The script uses the AWS Glue job bookmarks to ensure that it processes newly delivered data. To find more information about bookmarks in the AWS Glue documentation, see <a href="https://docs.aws.amazon.com/glue/latest/dg/monitor-continuations.html" target="_blank" rel="noopener">Tracking Processed Data Using Job Bookmarks</a>.</p> 
<h2>Querying your optimized data in Athena: examples</h2> 
<p>Now that you’ve converted your data from row-based log files to columnar-based Parquet, you can write queries against this data using Athena. After the first run of the script, the tables specified in the AWS Glue ETL job properties are created for you. Here are several sample queries to get you started.</p> 
<h3>Example 1: Most requested S3 keys</h3> 
<div class="hide-language"> 
 <pre><code class="lang-sql">SELECT key, COUNT(*) AS count
FROM &quot;aws_service_logs&quot;.&quot;s3_access&quot;
WHERE operation IN ('REST.GET.OBJECT', 'REST.COPY.OBJECT', 'REST.COPY.OBJECT_GET')
GROUP BY 1
ORDER BY 2 DESC
limit 100;</code></pre> 
</div> 
<h3><strong>Example 2: Top IP addresses that accessed the bucket yesterday</strong></h3> 
<div class="hide-language"> 
 <pre><code class="lang-sql">SELECT remote_ip, COUNT(*) FROM &quot;aws_service_logs&quot;.&quot;s3_access&quot;
WHERE year=date_format(current_date, '%Y') AND month=date_format(current_date, '%m') AND day=date_format(current_date + interval '-1' day, '%d')
GROUP BY 1
ORDER BY 2 DESC
limit 100;</code></pre> 
</div> 
<p>Note the use of numbers instead of strings in the use of the GROUP BY and ORDER BY operations. This is one of the optimizations for Athena queries. For other optimizations, be sure to check out the <u><a href="https://aws.amazon.com/blogs/big-data/top-10-performance-tuning-tips-for-amazon-athena/" target="_blank" rel="noopener">Top 10 Performance Tuning Tips</a></u> blog post.</p> 
<p>In addition, we use the year, month, and day partition columns to limit the amount of data scanned and decrease the cost of the query.</p> 
<h2>Summary</h2> 
<p>This post introduces a new open-source library that you can use to efficiently process various types of AWS service logs using AWS Glue. The library automates the application of common best practices to allow high-performing and cost-effective querying of the data using Amazon Athena and Amazon Redshift. We hope this library comes in handy, and we’re open to pull requests. If you want to add a new log type, check out the code in the AWS Labs <u><a href="https://github.com/awslabs/athena-glue-service-logs" target="_blank" rel="noopener">athena-glue-service-logs repository</a></u>!</p> 
<p>&nbsp;</p> 
<hr /> 
<h3>About the Author</h3> 
<p><img class="size-full wp-image-6866 alignleft" src="https://d2908q01vomqb2.cloudfront.net/b6692ea5df920cad691c20319a6fffd7a4a766b8/2019/05/02/Damon.png" alt="" width="113" height="152" /><strong>Damon Cortesi is a big data architect with Amazon Web Services</strong>.</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>&nbsp;</p>