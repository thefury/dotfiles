<p>Customers take advantage of the elasticity in <a href="https://aws.amazon.com/emr/">Amazon EMR</a> to save costs by scaling in clusters when workflows are completed, or when running lighter jobs. This also applies to launching clusters with low-cost <a href="https://aws.amazon.com/ec2/spot/">Amazon EC2 spot instances</a>.</p> 
<p>The <a href="https://docs.aws.amazon.com/emr/latest/ManagementGuide/emr-automatic-scaling.html">Automatic Scaling</a> feature in Amazon EMR lets customers dynamically scale clusters in and out, based on cluster usage or other job-related metrics. These features help you use resources efficiently, but they can also cause EC2 instances to shut down in the middle of a running job. This could result in the loss of computation and data, which can affect the stability of the job or result in duplicate work through recomputing.</p> 
<p>To gracefully shut down nodes without affecting running jobs, Amazon EMR uses <a href="https://aws.amazon.com/emr/details/hadoop/">Apache Hadoop</a>‘s decommissioning mechanism, which the Amazon EMR team developed and contributed back to the community. This works well for most Hadoop workloads, but not so much for <a href="https://spark.apache.org/">Apache Spark</a>. Spark currently faces various shortcomings while dealing with node loss. This can cause jobs to get stuck trying to recover and recompute lost tasks and data, and in some cases eventually crashing the job. For more information about some of the open issues in Spark, see the following links:</p> 
<ul> 
 <li><a href="https://issues.apache.org/jira/browse/SPARK-20178">Fetch failure related issues</a></li> 
 <li><a href="https://issues.apache.org/jira/browse/SPARK-20628">Track nodes which are shutting down and avoid scheduling tasks on them</a></li> 
</ul> 
<p>To avoid some of these issues and help customers take full advantage of Amazon EMR’s elasticity features with Spark, Amazon EMR has customizations to open-source Spark that make it more resilient to node loss. Recomputation is minimized, and jobs can recover faster from node failures and EC2 instance termination. These improvements are in Amazon EMR release version 5.9.0 and later.</p> 
<p>This blog post provides an overview of the issues with how open-source Spark handles node loss and the improvements in Amazon EMR to address the issues.<span id="more-6511"></span></p> 
<h2>How Spark handles node loss</h2> 
<p>When a node goes down during an active Spark job, it has the following risks:</p> 
<ul> 
 <li>Tasks that are actively running on the node might fail to complete and have to run on another node.</li> 
 <li>Cached RDDs (resilient distributed dataset) on the node might be lost. While this does impact performance, it does not cause failures or impact the stability of the application.</li> 
 <li>Shuffle output files in memory, or those written to disk on the node, would be lost. Because Amazon EMR enables the <a href="https://spark.apache.org/docs/latest/job-scheduling.html#dynamic-resource-allocation">External Shuffle Service</a> by default, the shuffle output is written to disk. Losing shuffle files can bring the application to a halt until they are recomputed on another active node, because future tasks might depend on them. For more information about shuffle operations, see <a href="https://spark.apache.org/docs/latest/rdd-programming-guide.html#shuffle-operations">Shuffle operations</a>.</li> 
</ul> 
<p>To recover from node loss, Spark should be able to do the following:</p> 
<ul> 
 <li>If actively running tasks are lost, they must be scheduled on another node. In addition, computing for the unscheduled remaining tasks must resume.</li> 
 <li>Shuffle output that was computed on the lost node must be recomputed by re-executing the tasks that produced those shuffle blocks.</li> 
</ul> 
<p>The following is the sequence of events for Spark to recover when a node is lost:</p> 
<ul> 
 <li>Spark considers actively running tasks on the node as failed and reruns them on another active node.</li> 
 <li>If the node had shuffle output files that are needed by future tasks, the target executors on other active nodes get a <em><a href="https://github.com/apache/spark/blob/master/core/src/main/scala/org/apache/spark/shuffle/FetchFailedException.scala">FetchFailedException</a></em> while trying to fetch missing shuffle blocks from the failed node.</li> 
 <li>When the <em>FetchFailedException</em> happens, the target executors retry fetching the blocks from the failed node for a time determined by the <em>spark</em><em>.shuffle.io.maxRetries</em> and <em>spark</em><em>.shuffle.io.retryWait</em> configuration values. After all the retry attempts are exhausted, the failure is propagated to the driver.</li> 
 <li>When the driver receives the <em>FetchFailedException</em>, it marks the currently running shuffle stage during which the failure occurred as failed and stops its execution. It also marks the shuffle output on the node or executors from which shuffle blocks could not be fetched as unavailable/lost, so that they can be recomputed. This triggers the previous Map stage to re-attempt recomputing those missing shuffle blocks.</li> 
 <li>After the missing shuffle output is computed, a re-attempt of the failed shuffle stage is triggered to resume the job from where it stopped. It then runs tasks that failed or had not been scheduled yet.</li> 
</ul> 
<h3><strong>Issues with Spark’s handling of node loss</strong></h3> 
<p>Spark’s recovery process helps it recover random executor and node failures that can occur in any cloud environment. However, the recovery process begins only after the node has already failed and Spark gets a <em>FetchFailedException</em> while trying to fetch shuffle blocks. This causes some of the issues described in this section.</p> 
<p>Amazon EMR can begin the recovery early, as it knows when and which nodes are going down because of a manual resize, an EC2-triggered Spot instance termination, or an automatic scaling event. It can inform Spark immediately about these nodes, so that Spark can take pro-active actions to gracefully handle loss of nodes and start recovery early. However, Spark currently does not have any mechanism through which it can be notified that a node is going down, such as YARN decommissioning. Therefore, it can not take immediate and relevant actions to help recover faster. As a result, here are some of the issues with Spark’s recovery:</p> 
<ul> 
 <li>The node goes down in the middle of the Map stage, as shown in the following diagram:<br /> <img class="alignnone size-full wp-image-6512" src="https://d2908q01vomqb2.cloudfront.net/b6692ea5df920cad691c20319a6fffd7a4a766b8/2019/02/20/SparkResiliencyEMR1.png" alt="" width="701" height="410" /></li> 
</ul> 
<p style="padding-left: 30px">In this scenario, the shuffle stage is scheduled unnecessarily, and the application must wait for the <em>FetchFailedException</em> before recomputing the lost shuffle. This takes a lot of time. Instead, it would be better if all lost shuffles could be immediately recomputed in the Map stage before even proceeding to the shuffle stage.</p> 
<ul> 
 <li>The node goes down in the middle of a shuffle stage, as shown in the following diagram:<br /> <img class="alignnone size-full wp-image-6513" src="https://d2908q01vomqb2.cloudfront.net/b6692ea5df920cad691c20319a6fffd7a4a766b8/2019/02/20/SparkResiliencyEMR2.png" alt="" width="778" height="435" /></li> 
</ul> 
<p style="padding-left: 30px">If there was way to immediately inform Spark about node loss, instead of it depending on <em>FetchFailedException</em> and retry fetching, that would save on recovery time.</p> 
<ul> 
 <li>The Spark driver starts recomputation when it gets the first <em>FetchFailedException</em>. It considers the shuffle files on the lost node as missing. However, if multiple nodes go down at the same time, in its first re-attempt of the previous Map stage, the Spark driver recomputes only the shuffle output for the <em>first node</em> from which it received a <em>FetchFailedException</em>. In the short time between receiving the first fetch failure and starting the re-attempt, it is possible that the driver receives fetch failures from other failed nodes. As a result, it can recompute shuffles for multiple lost nodes in the same re-attempt, but there is no guarantee.In most cases, even though nodes go down at the same time, Spark requires multiple re-attempts of the map and shuffle stages to recompute all of the lost shuffle output. This can easily cause a job to be blocked for a significant amount of time. Ideally, Spark could recompute in only one retry the shuffle output on all nodes that were lost around the same time.</li> 
</ul> 
<ul> 
 <li>As long as it can reach a node that is about to go down, Spark can continue to schedule more tasks on it. This causes more shuffle outputs to be computed, which may eventually need to be recomputed. Ideally, these tasks can be redirected to healthy nodes to prevent recomputation and improve recovery time.</li> 
</ul> 
<ul> 
 <li>Spark has a limit on the number of consecutive failed attempts allowed for a stage before it aborts a job. This is configurable with <em>spark.stage.maxConsecutiveAttempts</em>. When a node fails and a&nbsp;<em>FetchFailedException</em> occurs, Spark marks running shuffle stage as failed and triggers a re-attempt after computing the missing shuffle outputs. Frequent scaling of nodes during shuffle stages can easily cause stage failures to reach the threshold and abort the jobs. Ideally, when a stage fails for valid reasons such as a manual scale in, an automatic scaling event, or an EC2-triggered Spot instance termination, there should be a way to tell Spark not to count this toward <em>spark.stage.maxConsecutiveAttempts</em> for that stage.</li> 
</ul> 
<h2>How Amazon EMR resolves these issues</h2> 
<p><strong>&nbsp;</strong>This section describes the three main enhancements that Amazon EMR has done to its Spark to resolve the issues described in the previous section.</p> 
<h3>Integrate with YARN’s decommissioning mechanism</h3> 
<p><strong>&nbsp;</strong>Spark on Amazon EMR uses YARN as the underlying manager for cluster resources. Amazon EMR has its own implementation of a graceful decommissioning mechanism for YARN that provides a way to gracefully shut down YARN node managers by not scheduling new containers on a node in the <strong>Decommissioning</strong> state. Amazon EMR does this by waiting for the existing tasks on running containers to complete, or time out, before the node is decommissioned. This decommissioning mechanism has recently been contributed back to open source Hadoop.</p> 
<p>We integrated Spark with YARN’s decommissioning mechanism so that the Spark driver is notified when a node goes through <strong>Decommissioning</strong> or <strong>Decommissioned</strong> states in YARN. This is shown in the following diagram:<br /> <img class="alignnone size-full wp-image-6514" src="https://d2908q01vomqb2.cloudfront.net/b6692ea5df920cad691c20319a6fffd7a4a766b8/2019/02/20/SparkResiliencyEMR3.png" alt="" width="697" height="208" /></p> 
<p>This notification allows the driver to take appropriate actions and start the recovery early, because all nodes go through the decommissioning process before being removed.</p> 
<h3>Extend Spark’s blacklisting mechanism</h3> 
<p>YARN’s decommissioning mechanism works well for Hadoop MapReduce jobs by not launching any more containers on decommissioning nodes. This prevents more Hadoop MapReduce tasks from being scheduled on that node. However, this does not work well for Spark jobs because in Spark each executor is assigned a YARN container that is long-lived and keeps receiving tasks.</p> 
<p>Preventing new containers from being launched only prevents more executors from being assigned to the node. Already active executors/containers continue to schedule new tasks until the node goes down, and they can end up failing and have to be rerun. Also, if these tasks write shuffle output, they would also be lost. This increases the recomputation and the time that it takes for recovery.</p> 
<p>To address this, Amazon EMR extends Spark’s <a href="https://issues.apache.org/jira/browse/SPARK-8425">blacklisting mechanism</a> to blacklist a node when the Spark driver receives a YARN decommissioning signal for it. This is shown in the following diagram:</p> 
<p><img class="alignnone size-full wp-image-6515" src="https://d2908q01vomqb2.cloudfront.net/b6692ea5df920cad691c20319a6fffd7a4a766b8/2019/02/20/SparkResiliencyEMR4.png" alt="" width="700" height="328" /></p> 
<p>This prevents new tasks from being scheduled on the blacklisted node. Instead they are scheduled on healthy nodes. As soon as tasks already running on the node are complete, the node can be safely decommissioned without the risk of task failures or losses. This also speeds up the recovery process by not producing more shuffle output on a node that is going down. This reduces the number of shuffle outputs to be recomputed. If the node comes out of the <strong>Decommissioning</strong> state and is active again, Amazon EMR removes the node from the blacklists so that new tasks can be scheduled on it.</p> 
<p>This blacklisting extension is enabled by default in Amazon EMR with the <em>spark.blacklist.decommissioning.enabled</em> property set to true. You can control the time for which the node is blacklisted using the <em>spark.blacklist.decommissioning.timeout</em> property, which is set to <strong>1 hour</strong> by default, equal to the default value for <em>yarn.resourcemanager.nodemanager-graceful-decommission-timeout-secs</em>. We recommend setting <em>spark.blacklist.decommissioning.timeout</em> to a value equal to or greater than <em>yarn.resourcemanager.nodemanager-graceful-decommission-timeout-secs</em> to make sure that Amazon EMR blacklists the node for the entire decommissioning period.</p> 
<h3>Actions for decommissioned nodes</h3> 
<p>After a node is decommissioning, no new tasks are getting scheduled, and the active containers become idle (or the timeout expires), the node gets decommissioned<em>.</em> When the Spark driver receives the decommissioned signal, it can take the following additional actions to start the recovery process sooner rather than waiting for a fetch failure to occur:</p> 
<ul> 
 <li>All of the shuffle outputs on the decommissioned node are unregistered, thus marking them as unavailable. Amazon EMR enables this by default with the setting&nbsp;<em>spark.resourceManager.cleanupExpiredHost</em> set to true. This has the following advantages: 
  <ul> 
   <li>If a node is lost in the middle of a map stage and gets decommissioned, Spark initiates recovery and recomputes the lost shuffle outputs on the decommissioned node, before proceeding to the next Stage. This prevents fetch failures in the shuffle stage, because Spark has all of the shuffle blocks computed and available at the end of map stage, which significantly speeds up recovery.</li> 
   <li>If a node is lost in the middle of a shuffle stage, the target executors trying to get shuffle blocks from the lost node immediately notice that the shuffle output is unavailable. It then sends the failure to the driver instead of retrying and failing multiple times to fetch them. The driver then immediately fails the stage and starts recomputing the lost shuffle output. This reduces the time spent trying to fetch shuffle blocks from lost nodes.</li> 
   <li>The most significant advantage of unregistering shuffle outputs is when a cluster is scaled in by a large number of nodes. Because all of the nodes go down around the same time, they all get decommissioned around the same time, and their shuffle outputs are unregistered. When Spark schedules the first re-attempt to compute the missing blocks, it notices all of the missing blocks from decommissioned nodes and recovers in only one attempt. This speeds up the recovery process significantly over the open-source Spark implementation, where stages might be rescheduled multiple times to recompute missing shuffles from all nodes, and prevent jobs from being stuck for hours failing and recomputing.</li> 
  </ul> </li> 
 <li>When a stage fails because of fetch failures from a node being decommissioned, by default, Amazon EMR does not count the stage failure toward the maximum number of failures allowed for a stage as set by <em>spark.stage.maxConsecutiveAttempts</em>. This is determined by the setting <em>spark.stage.attempt.ignoreOnDecommissionFetchFailure </em>being set to true. This prevents a job from failing if a stage fails multiple times because of node failures for valid reasons such as a manual resize, an automatic scaling event, or an EC2-triggered Spot instance termination.</li> 
</ul> 
<h2>Conclusion</h2> 
<p>This post described how Spark handles node loss and some of the issues that can occur if a cluster is scaled in during an active Spark job. It also showed the customizations that Amazon EMR has built on Spark, and the configurations available to make Spark on Amazon EMR more resilient, so that you can take full advantage of the elasticity features offered by Amazon EMR.</p> 
<p>If you have questions or suggestions, please leave a comment.</p> 
<p>&nbsp;</p> 
<hr /> 
<h3>About the Author</h3> 
<p><img class="size-full wp-image-6523 alignleft" src="https://d2908q01vomqb2.cloudfront.net/b6692ea5df920cad691c20319a6fffd7a4a766b8/2019/02/22/uditme-1.png" alt="" width="113" height="157" /><strong>Udit Mehrotra is a software development engineer at Amazon Web Services. </strong>He works on cutting-edge features of EMR and is also involved in open source projects such as Apache Spark, Apache Hadoop and Apache Hive. In his spare time, he likes to play guitar, travel, binge watch and hang out with friends.</p>