<p><em>Chris Baker has been a senior software developer in academia, industry and government for over 20 years. Previously a scientist for the US Department of Energy, he developed software for the world&#39;s largest supercomputers and published research in leading international journals. He is currently a software engineer on the Nomad team at HashiCorp.</em></p>

<p><em>Renaud Gaubert has been working since 2017 at NVIDIA on making GPU applications easier to deploy and manage in data centers. He focuses on supporting GPU-accelerated machine learning frameworks in container orchestration systems such as Kubernetes, Docker swarm, and Nomad.</em></p>

<p>HashiCorp <a href="https://www.hashicorp.com/blog/hashicorp-nomad-0-9">Nomad 0.9</a> introduces device plugins which support an extensible set of devices for scheduling and deploying workloads. A device plugin allows physical hardware devices to be detected, fingerprinted, and made available to the Nomad job scheduler. The 0.9 release includes a device plugin for NVIDIA GPUs. Some example use cases are:</p>

<ul>
<li>  Compute-intensive workloads employing accelerators like GPUs or TPUs</li>
<li>  Hardware security modules for securing applications and infrastructure</li>
<li>  Additional programmable devices</li>
</ul>

<p>This post describes the device plugin system, introduces NVIDIA GPU support, and gives an example of GPU-accelerated machine-learning workflows using this capability.</p>

<h2>Device Plugins</h2>

<p><a href="https://www.nomadproject.io/docs/devices/index.html">Device plugins</a> represent a new feature in Nomad 0.9. They allow the Nomad client to discover available hardware resources in addition to existing built-in resources such as CPU, memory, and disk. A device plugin detects devices and fingerprints their attributes. When scheduling a task using resources associated with a device plugin, the plugin also assists the Nomad client in making the allocated device available to the task.</p>

<p>During fingerprinting, a device plugin reports the number of detected devices, general information about each device (vendor, type, and model), and device-specific attributes (e.g., available memory, hardware features). The information returned by the plugin passes from the client to the server and is made available for use in scheduling jobs, using the <a href="https://www.nomadproject.io/docs/job-specification/device.html#device-parameters">device stanza</a> in the task’s resource stanza, for example:
<code>
resources { 
    device &quot;vendor/type/model&quot;  { 
        count =  2 
        constraint {  ...  } 
        affinity {  ...  }  
        }  
    }
</code>
This stanza allows selection of custom devices. Users can indicate their requirements to varying degrees of specificity. For example, a user can specify <code>nvidia/gpu</code> to get any NVIDIA GPU, or they can specify the exact model they want, such as <code>nvidia/gpu/1080ti</code>. In addition to specifying some number of necessary devices, the device stanza supports both <a href="https://www.nomadproject.io/docs/job-specification/affinity.html">affinities</a> and <a href="https://www.nomadproject.io/docs/job-specification/constraint.html">constraints</a> on device resources. These allow specifying device preferences and/or constraints using any of the device attributes fingerprinted by the device plugin.</p>

<p>In keeping with Nomad’s goal of easy cluster deployment, registering these plugins does not require recompiling Nomad. It’s only necessary to place them on the client nodes alongside the Nomad binary.</p>

<h2>NVIDIA GPU Device Plugin</h2>

<p>While originally dedicated to computer graphics computations, graphics processing units (GPUs) have become critical compute resources for workloads, ranging from high-performance scientific computing to machine learning to cryptocurrency mining. We bundle the <a href="https://www.nomadproject.io/docs/devices/nvidia.html">NVIDIA GPU device plugin</a> as part of the Nomad 0.9 binary in order to facilitate orchestrating GPU-accelerated workloads on Nomad clusters.</p>

<p>The NVIDIA device plugin first scans the client node for suitable NVIDIA GPUs, then fingerprints their hardware and capabilities, including clock speeds, driver version, and memory size. The plugin ultimately reports discovered devices as NVIDIA resources for the node. For example, the following node status indicates a GPU device discovered by the NVIDIA device plugin, along with all of the fingerprinted attributes of that device:
```
$ nomad node status -verbose 1d6 
...<br>
Host Resource Utilization 
CPU     Memory          Disk<br>
181/24000 MHz  955  MiB/60  GiB     4.6  GiB/97  GiB  </p>

<p>Device  Resource  Utilization 
nvidia/gpu/Tesla V100-SXM2-16GB[...]  0  /  16130  MiB<br>
...<br>
Device  Group  Attributes<br>
Device  Group  = nvidia/gpu/Tesla V100-SXM2-16GB 
bar1 =  16384  MiB 
cores<em>clock =  1530  MHz 
display</em>state =  Enabled 
driver<em>version =  418.39 
memory</em>clock =  877<br>
MHz memory =  16130<br>
MiB pci<em>bandwidth =  15760 MB/s
persistence</em>mode =<br>
Enabled power =  300 W
<code>
The Nomad job specification’s resource stanza works with any detected and available devices. The following example shows a resource stanza that requests 2 NVIDIA GPUs. The label “nvidia/gpu” indicates a requirement for devices of type “gpu” with vendor “nvidia”. A constraint stanza indicates memory requirement using [human-readable units](https://www.nomadproject.io/docs/job-specification/device.html#attribute-units-and-conversions) while an affinity stanza indicates an optional preference for a device with model Tesla. The scheduler filters nodes that don’t have at least two devices matching the constraints and then ranks according to the satisfaction of any affinities. When the task is scheduled to a node, the scheduler marks the GPUs made available to the task as allocated and unavailable to other jobs for the lifetime of this task.
</code>
resources { 
    device &quot;nvidia/gpu&quot;  { </p>

<pre><code>    count =  2 

    constraint { 
        attribute =  &quot;${device.attr.memory}&quot;  
        operator  =  &quot;&gt;=&quot; 
        value =  &quot;4 GiB&quot;  
    } 
    affinity { 
        attribute =  &quot;${device.model}&quot;  
        operator  =  &quot;regexp&quot; 
        value =  &quot;Tesla&quot;  
    }  
}  
</code></pre>

<p>}
```</p>

<p>The video demonstrates using a GPU-enabled Nomad cluster to schedule NVIDIA TensorRT Inference Server platform.</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/Q-eINv25TmY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<p>To run the demo yourself in AWS, you can provision Nomad infrastructure using this <a href="https://github.com/hashicorp/nomad/tree/master/terraform/aws/env/us-east">Terraform configuration</a> and run the <a href="https://github.com/hashicorp/nomad/tree/master/terraform/examples/tensorrt">TensorRT example job</a>.</p>

<h1>Integration with Nomad</h1>

<p>Figure 1 shows how the <code>libnvidia-container</code> integrates with the Nomad client, specifically at the <code>runc</code> layer. We use a custom OCI prestart hook called <code>nvidia-container-runtime-hook</code> in order to enable GPU containers in Docker (more information about hooks can be found in the OCI runtime spec).</p>

<p><a href="https://devblogs.nvidia.com/wp-content/uploads/2019/05/pasted-image-0.png"><img src="https://devblogs.nvidia.com/wp-content/uploads/2019/05/pasted-image-0-625x212.png" alt="GPU architecture diagram and how Nomad hooks in diagram"></a></p>

<p><strong>Figure 1. GPU Container Architecture Diagram with Nomad agent hooked in</strong></p>

<p>At container creation time, the prestart hook uses environment variables to check whether the container is GPU-enabled and uses the container runtime library to expose the NVIDIA GPUs to the container.</p>

<p>Nomad’s plugin-based integration strategy yields several advantages for users:</p>

<ul>
<li>  <strong>Production Ready.</strong> The NVIDIA runtime library (libnvidia-container) and the prestart hook have been running in production for over 2 years in widely different environments. NVIDIA also ensures that CUDA containers that use the runtime library will remain supported and benefit from the latest features.</li>
<li>  <strong>Simple Feature Integration.</strong> New CUDA platform features (e.g. CUDA compatibility) are available without having to upgrade Nomad.</li>
</ul>

<h1>Typical GPU Deep Learning Inference Application</h1>

<p>The use cases for running orchestration software with GPUs range from managing a GPU cluster for scientists to running Deep Learning models as production services. Let’s focus on the latter use case and how this maps into a smooth experience with Nomad.</p>

<p>The result of the many hours it takes to train a neural network is a model. The model describes the structure of your neural network (layers, weights, etc) and adheres to a specific format depending on the framework that you use. If you or your data science team have built, trained, tweaked and tuned a model, Nomad is a great choice for going to production.</p>

<p>Going to production with a Deep Learning model is far from simple, so let’s walk through the various concerns that exist:</p>

<ol>
<li> <strong>Request Routing.</strong> You need to be able to accept incoming requests (HTTP, GRPC, …) and feed them to your network.</li>
<li> <strong>Monitoring.</strong> You must be able to observe how your network performs and how much resources it uses.</li>
<li> <strong>Parallelization.</strong> You require reasonable latency and throughput, and will likely need to handle requests in parallel</li>
<li> <strong>Scalability.</strong> You want the number of instances in your cluster to grow with the demand.</li>
<li> <strong>Cost.</strong> You must make optimal use of the available GPUs to get the maximum possible performance to cost ratio.</li>
<li> <strong>Flexibility.</strong> This allows you to A/B test different versions of your model.</li>
</ol>

<p>You can address many of the concerns above through a combination of the orchestration software and the inference solution. For example, NVIDIA’s TensorRT Inference Server makes optimal use of the available GPUs to obtain the maximum possible performance, provides metrics to Prometheus, and takes care of handling incoming network requests via HTTPS and gRPC. We use the TensorRT Inference Server which allows us to benefit from the GPU’s ability to significantly speed up the compute time, as seen in Figure 2.</p>

<p><a href="https://devblogs.nvidia.com/wp-content/uploads/2019/05/pasted-image-0-2.png"><img src="https://devblogs.nvidia.com/wp-content/uploads/2019/05/pasted-image-0-2-625x408.png" alt="TensorRT performance comparison graph"></a></p>

<p><strong>Figure 2. NVIDIA TensorRT Inference Performance comparison</strong></p>

<p>Now let’s look at the process of taking a known model (RESNET-50) and getting to a production setup that can serve thousands of requests. This uses the following steps:</p>

<ol>
<li> Writing the TensorRT inference server Nomad job</li>
<li> Feeding the model to the TensorRT inference server</li>
<li> Deploying a sample frontend web app to communicate with the inference server using HTTP</li>
</ol>

<h3><strong>Step 1. Writing the TensorRT inference server job</strong></h3>

<p>You can download the TensorRT inference server container from the <a href="http://nvcr.io/nvidia/tensorrtserver:19.02-py3">NVIDIA container registry</a>.</p>

<p>It requires substantial setup, such as specifying the different ports used to communicate over HTTP, gRPC, or its metrics. It also requires specifying the number of devices to use. As a side note, the server can serve requests for multiple models in the same container on multiple GPUs.</p>

<p>This is a much better architecture than one server per model per GPU, allowing “sharing” of the compute power of the GPU to multiple models.
<code>
job &quot;tensorrt&quot;  {  
    ... 
    task &quot;rtserver&quot;  { 
        config { 
            image =  &quot;nvcr.io/nvidia/tensorrtserver:19.02-py3&quot;  
            ... 
            shm_size=1024 
            port_map { 
                http =  8000 
                grpc =  8001 
                metrics =  8002  
            } 
            ulimit { 
                memlock =  &quot;-1&quot; 
                stack =  &quot;67108864&quot;  
            } 
            resources { 
                device &quot;nvidia/gpu&quot;  { 
                    count =  2  
                }  
                ...  
            }  
        }
</code>
You can customize this configuration for your needs using this <a href="https://github.com/hashicorp/nomad/blob/634592eb15601c8508a6d71d9a0dd44d1b63c21e/terraform/examples/tensorrt/tensorrt-demo.nomad#L5-L85">Nomad job file</a>.</p>

<h3><strong>Step 2. Feeding the model to the TensorRT inference server</strong></h3>

<p>The TensorRT inference server functions quite simply. When you start it, you tell it where to look for your models and it will try to load them according to the <a href="https://docs.nvidia.com/deeplearning/sdk/tensorrt-inference-server-master-branch-guide/docs/model_repository.html#model-versions">specification available</a> <a href="https://docs.nvidia.com/deeplearning/sdk/tensorrt-inference-server-master-branch-guide/docs/model_repository.html#model-versions">here</a> (supports many specifications).</p>

<p>In this example, we tell it to load a resnet-50 caffe2 model which comes with 4 files: the init network (that that initializes the parameters), the predict network (that runs the actual training), the config.pbtxt (which describes the layers), and finally the labels.txt which lists the labels (your model outputs a number which maps to a label).</p>

<p>The task specification below uses multiple instances of the Nomad <a href="https://www.nomadproject.io/docs/job-specification/artifact.html">artifact stanza</a> to download the models to the container before it starts. The “image”, “command”, and “args” parameters define the location of the Docker image and the command to run.</p>

<p>You have multiple options for feeding the model when using the TensorRT Inference Server:</p>

<ol>
<li> Here we feed the model through artifacts, as this is an example (not recommended for production).</li>
<li> You can build our own container extending from the base tensorrtserver image.</li>
<li> You can <a href="https://docs.nvidia.com/deeplearning/sdk/tensorrt-inference-server-master-branch-guide/docs/model_repository.html">create a “model store”</a> in one of the major cloud providers (AWS S3 bucket, GCP bucket, …).</li>
</ol>

<p>The below example is suitable for testing. When you go to production you might want to consider option (2) above, as it provides you with the most flexibility.
<code>
job &quot;tensorrt&quot;  {  
    ... 
    task &quot;rtserver&quot;  { 
        config { 
            image =  &quot;nvcr.io/nvidia/tensorrtserver:19.02-py3&quot;      
            command =  &quot;trtserver&quot; 
            args =  [  
                &quot;--model-store=${NOMAD_TASK_DIR}/models&quot;  
                ]  
            }  
    # load the example model into ${NOMAD_TASK_DIR}/models      
    artifact { 
        source =  &quot;http://download.caffe2.ai/.../resnet50/predict_net.pb&quot; 
        destination =  &quot;local/models/resnet50_netdef/1/model.netdef&quot; 
        mode =  &quot;file&quot;  
    } 
    artifact { 
        source =  &quot;http://download.caffe2.ai/.../resnet50/init_net.pb&quot; 
        destination =  &quot;local/models/resnet50_netdef/1/init_model.netdef&quot; 
        mode =  &quot;file&quot;  
    } 
    artifact { 
        source =  &quot;https://raw.githubusercontent.com/NVIDIA/.../config.pbtxt&quot; 
        destination =  &quot;local/models/resnet50_netdef/config.pbtxt&quot; 
        mode =  &quot;file&quot;  
    } 
    artifact { 
        source =  &quot;https://raw.githubusercontent.com/NVIDIA/.../labels.txt&quot; 
        destination =  &quot;local/models/resnet50_netdef/resnet50_labels.txt&quot; 
        mode =  &quot;file&quot;  }  ...
</code></p>

<h3><strong>Step 3. Deploying a sample frontend web app</strong></h3>

<p>You can interact with the server using the following CLI command (<a href="https://docs.nvidia.com/deeplearning/sdk/tensorrt-inference-server-master-branch-guide/docs/client.html">more on setting up the client</a>):
<code>
$ image_client.py -m resnet50_netdef -u $SERVER_IP -s INCEPTION -c 3 mug.jpg
</code>
However, in order to confirm that our model is able to handle HTTP requests, we deploy a sample web application which allows us to upload an image and send it to the inference server.</p>

<p><img src="https://devblogs.nvidia.com/wp-content/uploads/2019/05/pasted-image-0-1-170x300.png" alt="">We’ll deploy the tensorrt-frontend container, which is a simple HTML upload form that invokes the above command line in python.
<code>
task &quot;web&quot;  { 
    config { 
        image =  &quot;nvidia/tensorrt-labs:frontend&quot; 
        args =  [  
            &quot;main.py&quot;,  &quot;--server-ip&quot;,  &quot;${RTSERVER}&quot;  
        ]
          ...  
      } 
      resources {  
      ... 
      network { 
          port &quot;http&quot;  {  static  =  &quot;8888&quot;  }  
          }  
      }  
      template  { 
          data =  &lt;
</code>
In the above example, the template section allows us to point the frontend to the server. When we deploy this Nomad job we can quickly get to the following screen. Please check out the <a href="https://hashicorp.wistia.com/projects/l4kfcrs8a7">full demo</a> for more details.</p>

<p><em>Note that this blog post describes a deployment workflow and is not intended to showcase the best inference performance. The inference accuracy may be improved by pre-processing of the images.</em></p>

<h1>Try It Yourself</h1>

<p>The Nomad 0.9 <a href="https://www.nomadproject.io/docs/devices/index.html">device plugin</a> feature builds on Nomad’s mission of running any application on any infrastructure. The <a href="https://www.nomadproject.io/docs/devices/nvidia.html">NVIDIA GPU device plugin</a> gives us the ability to exploit NVIDIA GPUs for those workloads that benefit from GPU acceleration, using the same cluster scheduler that runs our non-GPU workloads. To learn more about Nomad itself, please visit the <a href="https://github.com/hashicorp/nomad/blob/master/README.md">README</a> page or the <a href="https://www.nomadproject.io/intro/index.html">Introduction to Nomad</a> documentation.</p>
