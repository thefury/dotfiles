<!-- SC_OFF --><div class="md"><p>I thought a type alias would be more elegant than embedding a struct. You see, if I create a new type <code>BigInt</code> that embeds <code>big.Int</code>, I&#39;d have to take care that the embedded big.Int is initialized at all times, and unless I reimplement big.Int&#39;s like Cmp, Add, Sub, all the code that depends on this new type needs to know that <code>BigInt</code>&#39;s methods actually receive a <code>big.Int</code> for their arguments. Which is stupid.</p> <p>So I tried aliasing a type. ``` type BigInt big.Int</p> <p>// String casts BigInt into big.Int and uses its String method. func (b <em>BigInt) String() string { bc := big.Int(</em>b) return bc.String() } ```</p> <p>But Setting the pointer receiver now seems impossible because I don&#39;t have access to the internals of big.Int. This following code doesn&#39;t work at all:</p> <p>``` // UnmarshalJSON casts BigInt into big.Int and uses its UnmarshalJSON method. func (b *BigInt) UnmarshalJSON(text []byte) error { bc := new(big.Int) err := bc.UnmarshalJSON(text) if err != nil { return err } b = b.Set(bc) return nil }</p> <p>// Set is different from big.Int.Set() in that you must use the value it returns func (b <em>BigInt) Set(i *big.Int) *BigInt { iB := BigInt(</em>i) b = &amp;iB return b } ```</p> <p>What can I do?</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href="https://www.reddit.com/user/ritchan"> /u/ritchan </a> <br/> <span><a href="https://www.reddit.com/r/golang/comments/bwbf7l/created_a_type_alias_for_bigint_but_i_cant_set_it/">[link]</a></span> &#32; <span><a href="https://www.reddit.com/r/golang/comments/bwbf7l/created_a_type_alias_for_bigint_but_i_cant_set_it/">[comments]</a></span>