<p>When I talk with customers and partners, I find that they are in different stages in the adoption of DevOps methodologies. They are automating the creation of application artifacts and the deployment of their applications to different infrastructure environments. In many cases, they are creating and supporting multiple applications using a variety of coding languages and artifacts.</p> 
<p>The management of these processes and artifacts can be challenging, but using the right tools and methodologies can simplify the process.</p> 
<p>In this post, I will show you how you can automate the creation and storage of application artifacts through the implementation of a pipeline and <a href="http://docs.aws.amazon.com/codepipeline/latest/userguide/actions.html">custom deploy action</a> in <a href="https://aws.amazon.com/codepipeline/">AWS CodePipeline</a>. The example includes a <a href="https://nodejs.org/en/">Node.js</a> code base stored in an <a href="https://aws.amazon.com/codecommit/">AWS CodeCommit</a> repository. A <a href="https://www.npmjs.com/">Node Package Manager</a> (<a href="https://docs.npmjs.com/getting-started/what-is-npm">npm</a>) artifact is built from the code base, and the build artifact is published to a <a href="https://jfrog.com/">JFrog</a> <a href="https://jfrog.com/artifactory/">Artifactory</a> npm repository.</p> 
<p>I frequently recommend AWS CodePipeline, the AWS <a href="https://aws.amazon.com/devops/continuous-integration/">continuous integration</a> and <a href="https://aws.amazon.com/devops/continuous-delivery/">continuous delivery</a> tool. You can use it to quickly innovate through integration and deployment of new features and bug fixes by building a workflow that automates the build, test, and deployment of new versions of your application. And, because AWS CodePipeline is extensible, it allows you to create a custom action that performs customized, automated actions on your behalf.</p> 
<p>JFrog’s Artifactory is a universal binary repository manager where you can manage multiple applications, their dependencies, and versions in one place. Artifactory also enables you to standardize the way you manage your package types across all applications developed in your company, no matter the code base or artifact type.</p> 
<p>If you already have a Node.js CodeCommit repository, a JFrog Artifactory host, and would like to automate the creation of the pipeline, including the custom action and CodeBuild project, you can use this <a href="https://aws.amazon.com/cloudformation/">AWS CloudFormation</a> <a href="https://github.com/aws-samples/aws-codepipeline-custom-job-worker-for-jfrog-artifactory/blob/add-complete-pipeline/codepipeline-templates/codepipeline-and-worker-in-vpc.yaml">template</a> to create your AWS CloudFormation stack.</p> 
<p>The project code can be found in this GitHub repository: <a href="https://github.com/aws-samples/aws-codepipeline-custom-job-worker-for-jfrog-artifactory">https://github.com/aws-samples/aws-codepipeline-custom-job-worker-for-jfrog-artifactory</a>.</p> 
<p>&nbsp;</p> 
<p><span style="text-decoration: underline"><strong>The AWS CodePipeline workflow</strong></span></p> 
<p><img class="aligncenter size-full wp-image-2473" src="https://d2908q01vomqb2.cloudfront.net/7719a1c782a1ba91c031a682a0a2f8658209adbf/2018/05/24/Screen-Shot-2018-05-24-at-9.03.04-AM.png" alt="" width="746" height="414" /></p> 
<p>This figure shows the path defined in the pipeline for this project. It starts with a change to Node.js source code committed to a private code repository in AWS CodeCommit. With this change, CodePipeline triggers <a href="https://aws.amazon.com/codebuild/">AWS CodeBuild</a> to create the npm package from the node.js source code. After the build, CodePipeline triggers the custom action job worker to commit the build artifact to the designated artifact repository in Artifactory.</p> 
<p>&nbsp;</p> 
<p>This blog post assumes you have already:</p> 
<p>&middot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Created a CodeCommit repository that contains a Node.js project.</p> 
<p>&middot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Configured a two-stage pipeline in AWS CodePipeline.</p> 
<p>The Source stage of the pipeline is configured to poll the Node.js CodeCommit repository. The Build stage is configured to use a CodeBuild project to build the npm package using a <a href="https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html">buildspec.yml</a> file located in the code repository.</p> 
<p>If you do not have a Node.js repository, you can create a CodeCommit repository that contains <a href="https://github.com/aws-samples/aws-codepipeline-custom-job-worker-for-jfrog-artifactory/tree/master/node-example">this simple ‘Hello World’ project</a>. This project also includes a buildspec.yml file that is used when you define your CodeBuild project. It defines the steps to be taken by CodeBuild to create the npm artifact.</p> 
<p>If you do not already have a pipeline set up in CodePipeline, you can use this <a href="https://github.com/aws-samples/aws-codepipeline-custom-job-worker-for-jfrog-artifactory/blob/add-complete-pipeline/codepipeline-templates/source-build-actions-codepipeline.json">template</a> to create a pipeline with a CodeCommit source action and a CodeBuild build action through the <a href="https://docs.aws.amazon.com/cli/latest/userguide/installing.html">AWS Command Line Interface</a> (AWS CLI). If you do not want to install the AWS CLI on your local machine, you can use <a href="https://aws.amazon.com/cloud9/">AWS Cloud9</a>, our managed integrated development environment (IDE), to interact with AWS APIs.</p> 
<p>In your development environment, open your favorite editor and fill out the template with values appropriate to your project. For information, see the <a href="https://github.com/aws-samples/aws-codepipeline-custom-job-worker-for-jfrog-artifactory/blob/add-complete-pipeline/codepipeline-templates/README.md">readme</a> in the GitHub repository.</p> 
<p>Use this CLI command to create the pipeline from the template:</p> 
<pre><code class="lang-bash">aws codepipeline create-pipeline --cli-input-json file://source-build-actions-codepipeline.json --region 'us-west-2'</code></pre> 
<p>It creates a pipeline that has a CodeCommit source action and a CodeBuild build action.</p> 
<p><span style="text-decoration: underline"><strong>Integrating JFrog Artifactory</strong></span></p> 
<p>JFrog Artifactory provides default repositories for your project needs. For my NPM package repository, I am using the default virtual npm repository (named npm) that is available in Artifactory Pro. You might want to consider creating a repository per project but for the example used in this post, using the default lets me get started without having to configure a new repository.</p> 
<p>I can use the steps in the <strong>Set Me Up -&gt; npm</strong> section on the landing page to configure my worker to interact with the default NPM repository.</p> 
<p>&nbsp;</p> 
<p><img class="aligncenter wp-image-2509 size-full" src="https://d2908q01vomqb2.cloudfront.net/7719a1c782a1ba91c031a682a0a2f8658209adbf/2018/05/24/set-me-up-1.png" alt="" width="574" height="413" /></p> 
<p><img class="aligncenter wp-image-2510 size-full" src="https://d2908q01vomqb2.cloudfront.net/7719a1c782a1ba91c031a682a0a2f8658209adbf/2018/05/24/set-me-up-2-resize.png" alt="" width="574" height="480" /></p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p><span style="text-decoration: underline"><strong>Custom actions in AWS CodePipeline</strong></span></p> 
<p>A custom action in AWS CodePipeline contains:</p> 
<p>&middot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="http://docs.aws.amazon.com/codepipeline/latest/userguide/actions-create-custom-action.html">custom action definition</a></p> 
<p>Describes the required values to run the custom action. I will define my custom action in the ‘Deploy’ category, identify the provider as ‘Artifactory’, of version ‘1’, and specify a variety of configurationProperties whose values will be defined when this stage is added to my pipeline.</p> 
<p>&middot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="https://docs.aws.amazon.com/codepipeline/latest/userguide/actions-create-custom-action.html#actions-create-custom-action-job-worker">custom action job worker</a></p> 
<p>Polls CodePipeline for a job, scanning for its action-definition properties. In this blog post, after a job has been found, the job worker does the work required to publish the npm artifact to the Artifactory repository.</p> 
<p>&nbsp;</p> 
<p>My <a href="https://github.com/aws-samples/aws-codepipeline-custom-job-worker-for-jfrog-artifactory/blob/master/custom-action/artifactory_custom_action_deploy_npm.json">custom action definition</a> in JSON:</p> 
<pre><code class="lang-json">{
    &quot;category&quot;: &quot;Deploy&quot;,
    &quot;configurationProperties&quot;: [{
        &quot;name&quot;: &quot;TypeOfArtifact&quot;,
        &quot;required&quot;: true,
        &quot;key&quot;: true,
        &quot;secret&quot;: false,
        &quot;description&quot;: &quot;Package type, ex. npm for node packages&quot;,
        &quot;type&quot;: &quot;String&quot;
    },
    {   &quot;name&quot;: &quot;RepoKey&quot;,
        &quot;required&quot;: true,
        &quot;key&quot;: true,
	&quot;secret&quot;: false,
	&quot;type&quot;: &quot;String&quot;,
	&quot;description&quot;: &quot;Name of the repository in which this artifact should be stored&quot;
    },
    {   &quot;name&quot;: &quot;UserName&quot;,
        &quot;required&quot;: true,
        &quot;key&quot;: true,
	&quot;secret&quot;: false,
	&quot;type&quot;: &quot;String&quot;,
	&quot;description&quot;: &quot;Username for authenticating with the repository&quot;
    },
    {   &quot;name&quot;: &quot;Password&quot;,
        &quot;required&quot;: true,
        &quot;key&quot;: true,
	&quot;secret&quot;: true,
	&quot;type&quot;: &quot;String&quot;,
	&quot;description&quot;: &quot;Password for authenticating with the repository&quot;
    },
    {   &quot;name&quot;: &quot;EmailAddress&quot;,
        &quot;required&quot;: true,
        &quot;key&quot;: true,
	&quot;secret&quot;: false,
	&quot;type&quot;: &quot;String&quot;,
	&quot;description&quot;: &quot;Email address used to authenticate with the repository&quot;
    },
    {   &quot;name&quot;: &quot;ArtifactoryHost&quot;,
        &quot;required&quot;: true,
        &quot;key&quot;: true,
	&quot;secret&quot;: false,
	&quot;type&quot;: &quot;String&quot;,
	&quot;description&quot;: &quot;Public address of Artifactory host, ex: https://myexamplehost.com or http://myexamplehost.com:8080&quot;
    }],
    &quot;provider&quot;: &quot;Artifactory&quot;,
    &quot;version&quot;: &quot;1&quot;,
    &quot;settings&quot;: {
        &quot;entityUrlTemplate&quot;: &quot;{Config:ArtifactoryHost}/artifactory/webapp/#/artifacts/browse/tree/General/{Config:RepoKey}&quot;
    },
    &quot;inputArtifactDetails&quot;: {
        &quot;maximumCount&quot;: 5,
        &quot;minimumCount&quot;: 1
    },
    &quot;outputArtifactDetails&quot;: {
        &quot;maximumCount&quot;: 5,
        &quot;minimumCount&quot;: 0
    }
}
</code></pre> 
<p>There are seven sections to the custom action definition:</p> 
<ul> 
 <li><code class="lang-bash">category</code>: This is the stage in which you will be creating this action. It can be Source, Build, Deploy, Test, Invoke, Approval. Except for source actions, the category section simply allows us to organize our actions. I am setting the category for my action as ‘Deploy’ because I’m using it to publish my node artifact to my Artifactory instance.</li> 
 <li><code class="lang-bash">configurationProperties</code>: These are the parameters or variables required for your project to authenticate and commit your artifact. In the case of my custom worker, I need: 
  <ul> 
   <li style="text-align: left"><code class="lang-bash">TypeOfArtifact</code>: In this case, npm, because it’s for the Node Package Manager.</li> 
   <li style="text-align: left"><code class="lang-bash">RepoKey</code>: The name of the repository. In this case, it’s the default npm.</li> 
   <li style="text-align: left"><code class="lang-bash">UserName</code> and Password for the user to authenticate with the Artifactory repository.</li> 
   <li style="text-align: left"><code class="lang-bash">EmailAddress</code> used to authenticate with the repository.</li> 
   <li style="text-align: left">Artifactory host name or IP address.</li> 
  </ul> </li> 
 <li><code class="lang-bash">provider</code>: The name you define for your custom action stage. I have named the provider Artifactory.</li> 
 <li><code class="lang-bash">version</code>: Version number for the custom action. Because this is the first version, I set the version number to 1.</li> 
 <li><code class="lang-bash">entityUrlTemplate</code>: This URL is presented to your users for the deploy stage along with the title you define in your provider. The link takes the user to their artifact repository page in the Artifactory host.</li> 
 <li><code class="lang-bash">inputArtifactDetails</code>: The number of artifacts to expect from the previous stage in the pipeline.</li> 
 <li><code class="lang-bash">outputArtifactDetails</code>: The number of artifacts that should be the result from the custom action stage. Later in this blog post, I define 0 for my output artifacts because I am publishing the artifact to the Artifactory repository as the final action.</li> 
</ul> 
<p>After I define the custom action in a JSON file, I use the AWS CLI to create the custom action type in CodePipeline:</p> 
<pre><code class="lang-bash">aws codepipeline create-custom-action-type --cli-input-json file://artifactory_custom_action_deploy_npm.json --region='us-west-2'</code></pre> 
<p>After I create the custom action type in the same region as my pipeline, I edit the pipeline to add a Deploy stage and configure it to use the custom action I created for Artifactory:</p> 
<p><img class="aligncenter wp-image-2511 size-full" src="https://d2908q01vomqb2.cloudfront.net/7719a1c782a1ba91c031a682a0a2f8658209adbf/2018/05/24/add-action-resize.png" alt="" width="574" height="262" /></p> 
<p>&nbsp;</p> 
<p><img class="aligncenter wp-image-2513 size-full" src="https://d2908q01vomqb2.cloudfront.net/7719a1c782a1ba91c031a682a0a2f8658209adbf/2018/05/24/add-action-2-resize.png" alt="" width="502" height="751" /></p> 
<p>&nbsp;</p> 
<p><img class="aligncenter wp-image-2516 size-full" src="https://d2908q01vomqb2.cloudfront.net/7719a1c782a1ba91c031a682a0a2f8658209adbf/2018/05/24/add-action-3-resize.png" alt="" width="502" height="659" /></p> 
<p><img class="aligncenter wp-image-2515 size-full" src="https://d2908q01vomqb2.cloudfront.net/7719a1c782a1ba91c031a682a0a2f8658209adbf/2018/05/24/add-action-4-resize.png" alt="" width="507" height="710" /></p> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>I have created a <a href="https://github.com/aws-samples/aws-codepipeline-custom-job-worker-for-jfrog-artifactory/blob/master/job-worker/npm_job_worker.py">custom worker</a> for the actions required to commit the npm artifact to the Artifactory repository. The worker is in Python and it runs in a loop on an Amazon EC2 instance. My custom worker polls for a deploy job and publishes the NPM artifact to the Artifactory repository.</p> 
<p>&nbsp;</p> 
<p>The EC2 instance is running Amazon Linux and has an IAM instance role attached that gives the worker permission to access CodePipeline. The worker process is as follows:</p> 
<ol> 
 <li>Take the configuration properties from the custom worker and poll CodePipeline for a custom action job.</li> 
 <li>After there is a job in the job queue with the appropriate category, provider, and version, acknowledge the job.</li> 
 <li>Download the zipped artifact created in the previous Build stage from the provided S3 buckets with the provided temporary credentials.</li> 
 <li>Unzip the artifact into a temporary directory.</li> 
 <li>A user-defined Artifactory user name and password is used to receive a temporary API key from Artifactory.</li> 
 <li>To avoid having to write the password to a file, use that temporary API key and user name to authenticate with the NPM repository.</li> 
 <li>Publish the Node.js package to the specified repository.</li> 
</ol> 
<p>Because I am running my custom worker on an Amazon Linux EC2 instance, I installed npm with the following command:</p> 
<pre><code class="lang-bash">sudo yum install nodejs npm --enablerepo=epel</code></pre> 
<p>For my custom worker, I used pip to install the required Python libraries:</p> 
<pre><code class="lang-bash">pip install boto3 requests</code></pre> 
<p>For a full Python package list, see <a href="https://github.com/aws-samples/aws-codepipeline-custom-job-worker-for-jfrog-artifactory/blob/master/job-worker/requirements.txt">requirements.txt</a> in the GitHub repository.</p> 
<p>Let’s take a look at some of the code snippets from the worker.</p> 
<p>First, the worker polls for jobs:</p> 
<pre><code class="lang-python">def action_type():
    ActionType = {
        'category': 'Deploy',
        'owner': 'Custom',
        'provider': 'Artifactory',
        'version': '1' }
    return(ActionType)

def poll_for_jobs():
    try:
        artifactory_action_type = action_type()
        print(artifactory_action_type)
        jobs = codepipeline.poll_for_jobs(actionTypeId=artifactory_action_type)
        while not jobs['jobs']:
            time.sleep(10)
            jobs = codepipeline.poll_for_jobs(actionTypeId=artifactory_action_type)
            if jobs['jobs']:
                print('Job found')
        return jobs['jobs'][0]
    except ClientError as e:
        print(&quot;Received an error: %s&quot; % str(e))
        raise
</code></pre> 
<p>&nbsp;</p> 
<p>When there is a job in the queue, the poller returns a number of values from the queue such as jobId, the input and output S3 buckets for artifacts, temporary credentials to access the S3 buckets, and other configuration details from the stage in the pipeline.</p> 
<p>&nbsp;</p> 
<p>Here is an example of the return response:</p> 
<pre><code class="lang-json">{
	'jobs': [
		{
			'nonce': '3',
			'data': {
				'inputArtifacts': [
					{
						'name': 'Output',
						'location': {
							'type': 'S3',
							's3Location': {
								'objectKey': 'ArtifactoryNPMwithCo/Output/Key,
							'bucketName': '123456789012-codepipelineartifact-us-west-2'
							}
						}
					}
				],
				'pipelineContext': {
						'action': {
							'name': 'Deploy'
						},
						'pipelineName': 'ArtifactoryNPMwithCodeDeploy',
						'stage': {
							'name': 'Deploy'
						}
				},
				'actionTypeId': {
					'category': 'Deploy',
					'owner': 'Custom',
					'version': '1',
					'provider': 'Artifactory'
				},
				'outputArtifacts': [
					{
						'name': 'ArtifactoryOut',
						'location': {
							'type': 'S3',
							's3Location': {
								'objectKey': 'ArtifactoryNPMwithCo/Artifactor/Key,
								'bucketName': '123456789012-codepipelineartifact-us-west-2'
							}
						}
					}
				],
				'actionConfiguration': {
					'configuration': {
						'UserName': 'admin',
						'ArtifactoryHost': 'https://artifactory.myexamplehost.com',
						'Password': 'xxx',
						'EmailAddress': 'me@myexamplehost.com',
						'TypeOfArtifact': 'npm',
						'RepoKey': 'npm'
					}
				},
				'artifactCredentials': {
					'secretAccessKey': 'SECRET',
			               'sessionToken':‘FQoDYXdz...XdndMF',
					'accessKeyId': 'ACCESSKEY'
					}
				},
				'id': 'a0eb',
				'accountId': '123456789012
			}
		],
		'ResponseMetadata': {
			'RetryAttempts': 0,
			'HTTPStatusCode': 200,
			'RequestId': a88b-cdbd5d08b9de',
			'HTTPHeaders': {
				'x-amzn-requestid': '77343c2d-eff4’,
				'content-length': '2461',
				'content-type': 'application/x-amz-json-1.1'
			}
		}
}
</code></pre> 
<p>&nbsp;</p> 
<p>After successfully receiving the job details, the worker sends an acknowledgement to CodePipeline to ensure that the work on the job is not duplicated by other workers watching for the same job:</p> 
<pre><code class="lang-python">def job_acknowledge(jobId, nonce):
    try:
        print('Acknowledging job')
        result = codepipeline.acknowledge_job(jobId=jobId, nonce=nonce)
        return result
    except Exception as e:
        print(&quot;Received an error when trying to acknowledge the job: %s&quot; % str(e))
        raise
</code></pre> 
<p>With the job now acknowledged, the worker publishes the source code artifact into the desired repository. The worker gets the value of the artifact S3 bucket and objectKey from the inputArtifacts in the response from the poll_for_jobs API request. Next, the worker creates a new directory in /tmp and downloads the S3 object into this directory:</p> 
<pre><code class="lang-python">def get_bucket_location(bucketName, init_client):
    region = init_client.get_bucket_location(Bucket=bucketName)['LocationConstraint']
    if not region:
        region = 'us-east-1'
    return region


def get_s3_artifact(bucketName, objectKey, ak, sk, st):
    init_s3 = boto3.client('s3')
    region = get_bucket_location(bucketName, init_s3)
    session = Session(aws_access_key_id=ak,
                      aws_secret_access_key=sk,
                      aws_session_token=st)

    s3 = session.resource('s3',
                          region_name=region,
                          config=botocore.client.Config(signature_version='s3v4'))
    try:
        tempdirname = tempfile.mkdtemp()
    except OSError as e:
        print('Could not write temp directory %s' % tempdirname)
        raise
    bucket = s3.Bucket(bucketName)
    obj = bucket.Object(objectKey)
    filename = tempdirname + '/' + objectKey
    try:
        if os.path.dirname(objectKey):
            directory = os.path.dirname(filename)
            os.makedirs(directory)
        print('Downloading the %s object and writing it to disk in %s location' % (objectKey, tempdirname))
        with open(filename, 'wb') as data:
            obj.download_fileobj(data)
    except ClientError as e:
        print('Downloading the object and writing the file to disk raised this error: ' + str(e))
        raise
    return(filename, tempdirname)   
</code></pre> 
<p>&nbsp;</p> 
<p>&nbsp;</p> 
<p>Because the downloaded artifact from S3 is a zip file, the worker must unzip it first. To have a clean area in which to work, I extract the downloaded zip archive into a new directory:</p> 
<pre><code class="lang-python">def unzip_codepipeline_artifact(artifact, origtmpdir):
    # create a new temp directory
    # Unzip artifact into new directory
    try:
        newtempdir = tempfile.mkdtemp()
        print('Extracting artifact %s into temporary directory %s' % (artifact, newtempdir))
        zip_ref = zipfile.ZipFile(artifact, 'r')
        zip_ref.extractall(newtempdir)
        zip_ref.close()
        shutil.rmtree(origtmpdir)
        return(os.listdir(newtempdir), newtempdir)
    except OSError as e:
        if e.errno != errno.EEXIST:
            shutil.rmtree(newtempdir)
            raise
</code></pre> 
<p>The worker now has the npm package that I want to store in my Artifactory NPM repository.</p> 
<p>To authenticate with the NPM repository, the worker requests a temporary token from the Artifactory host. After receiving this temporary token, it creates a <a href="https://docs.npmjs.com/files/npmrc#per-user-config-file">.npmrc file</a> in the worker user’s home directory that includes a hash of the user name and temporary token. After it has authenticated, the worker runs npm config set registry &lt;URL OF REPOSITORY&gt; to configure the npm registry value to be the Artifactory host.&nbsp; Next, the worker runs npm publish –registry &lt;URL OF REPOSITORY&gt;, which publishes the node package to the NPM repository in the Artifactory host.</p> 
<pre><code class="lang-python">def push_to_npm(configuration, artifact_list, temp_dir, jobId):
    reponame = configuration['RepoKey']
    art_type = configuration['TypeOfArtifact']
    print(&quot;Putting artifact into NPM repository &quot; + reponame)
    token, hostname, username = gen_artifactory_auth_token(configuration)
    npmconfigfile = create_npmconfig_file(configuration, username, token)
    url = hostname + '/artifactory/api/' + art_type + '/' + reponame
    print(&quot;Changing directory to &quot; + str(temp_dir))
    os.chdir(temp_dir)
    try:
        print(&quot;Publishing following files to the repository: %s &quot; % os.listdir(temp_dir))
        print(&quot;Sending artifact to Artifactory NPM registry URL: &quot; + url)
        subprocess.call([&quot;npm&quot;, &quot;config&quot;, &quot;set&quot;, &quot;registry&quot;, url])
        req = subprocess.call([&quot;npm&quot;, &quot;publish&quot;, &quot;--registry&quot;, url])
        print(&quot;Return code from npm publish: &quot; + str(req))
        if req != 0:
            err_msg = &quot;npm ERR! Recieved non OK response while sending response to Artifactory. Return code from npm publish: &quot; + str(req)
            signal_failure(jobId, err_msg)
        else:
            signal_success(jobId)
    except requests.exceptions.RequestException as e:
       print(&quot;Received an error when trying to commit artifact %s to repository %s: &quot; % (str(art_type), str(configuration['RepoKey']), str(e)))
       raise
    return(req, npmconfigfile)
</code></pre> 
<p>&nbsp;</p> 
<p>If the return value from publishing to the repository is not 0, the worker signals a failure to CodePipeline. If the value is 0, the worker signals success to CodePipeline to indicate that the stage of the pipeline has been completed successfully.</p> 
<p>For the custom worker code, see <a href="https://github.com/aws-samples/aws-codepipeline-custom-job-worker-for-jfrog-artifactory/blob/master/custom-action/npm_job_worker.py">npm_job_worker.py</a> in the GitHub repository.</p> 
<p>I run my custom worker on an EC2 instance using the command <code class="lang-bash">python npm_job_worker.py</code>, with an optional <code class="lang-bash">--version</code> flag that can be used to specify worker versions other than 1. Then I trigger a release change in my pipeline:</p> 
<p><img class="aligncenter wp-image-2517 size-full" src="https://d2908q01vomqb2.cloudfront.net/7719a1c782a1ba91c031a682a0a2f8658209adbf/2018/05/24/release-change-resize.png" alt="" width="261" height="710" /></p> 
<p>From my custom worker output logs, I have just committed a package named <code class="lang-bash">node_example</code> at version 1.0.3:</p> 
<div class="hide-language"> 
 <pre class="unlimited-height-code"><code class="lang-bash">On artifact: index.js
Committing to the repo: https://artifactory.myexamplehost.com/artifactory/api/npm/npm
Sending artifact to Artifactory URL: https:// artifactoryhost.myexamplehost.com/artifactory/api/npm/npm
npm config: 0
npm http PUT https://artifactory.myexamplehost.com/artifactory/api/npm/npm/node_example
npm http 201 https://artifactory.myexamplehost.com/artifactory/api/npm/npm/node_example
+ node_example@1.0.3
Return code from npm publish: 0
Signaling success to CodePipeline
</code></pre> 
</div> 
<p><img class="aligncenter wp-image-2518 size-full" src="https://d2908q01vomqb2.cloudfront.net/7719a1c782a1ba91c031a682a0a2f8658209adbf/2018/05/24/release-change-complete-resize.png" alt="" width="272" height="710" /></p> 
<p>After that has been built successfully, I can find my artifact in my Artifactory repository:</p> 
<p><img class="aligncenter wp-image-2519 size-full" src="https://d2908q01vomqb2.cloudfront.net/7719a1c782a1ba91c031a682a0a2f8658209adbf/2018/05/24/in-artifactory-resize.png" alt="" width="574" height="211" /></p> 
<p>To help you automate this process, I have created this AWS CloudFormation <a href="https://github.com/aws-samples/aws-codepipeline-custom-job-worker-for-jfrog-artifactory/blob/master/codepipeline-templates/codepipeline-and-worker-in-vpc.yaml">template</a> that automates the creation of the CodeBuild project, the <a href="https://github.com/aws-samples/aws-codepipeline-custom-job-worker-for-jfrog-artifactory/blob/master/custom-action/artifactory_custom_action_deploy_npm.json">custom action</a>, and the CodePipeline pipeline. It also launches the Amazon EC2-based <a href="https://github.com/aws-samples/aws-codepipeline-custom-job-worker-for-jfrog-artifactory/blob/master/job-worker/npm_job_worker.py">custom job worker</a> in an <a href="https://aws.amazon.com/autoscaling/">AWS Auto Scaling group</a>. This template requires you to have a VPC and CodeCommit repository for your Node.js project. If you do not currently have a VPC in which you want to run your custom worker EC2 instances, you can use this <a href="https://github.com/aws-quickstart/quickstart-aws-vpc">AWS QuickStart</a> to create one. If you do not have an existing Node.js project, I’ve provided a <a href="https://github.com/aws-samples/aws-codepipeline-custom-job-worker-for-jfrog-artifactory/tree/master/node-example">sample project</a> in the GitHub repository.</p> 
<p><span style="text-decoration: underline"><strong>Conclusion</strong></span></p> 
<p>I‘ve shown you the steps to integrate your JFrog Artifactory repository with your CodePipeline workflow. I’ve shown you how to create a custom action in CodePipeline and how to create a custom worker that works in your CI/CD pipeline. To dig deeper into custom actions and see how you can integrate your Artifactory repositories into your AWS CodePipeline projects, check out the full code base on <a href="https://github.com/aws-samples/aws-codepipeline-custom-job-worker-for-jfrog-artifactory">GitHub</a>.</p> 
<p>If you have any questions or feedback, feel free to reach out to us through the <a href="https://forums.aws.amazon.com/forum.jspa?forumID=197">AWS CodePipeline forum</a>.</p> 
<p><em>Erin McGill is a Solutions Architect in the AWS Partner Program with a focus on DevOps and automation tooling.</em></p>