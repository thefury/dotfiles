<p>As we showed in previous posts, it’s easy to put JSON items into Amazon DynamoDB, retrieve specific attributes with projection expressions, and fetch only data that meet some criteria with condition expressions. Now, let’s take a look at how we can conditionally modify existing items with <a href="http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.Modifying.html#Expressions.Modifying.UpdateExpressions">Update Expressions</a>. (Note: this code uses the same ProductCatalog table we used in Parts 1 and 2).</p> 
<p>In the following examples, we use the following helper method to perform conditional updates. It performs the UpdateItem operation with return_values set to return the old item. We also use the GetItem operation so the method can return both the old and new items for us to compare. (If the update condition in the request is not met, then the method sets the returned old item to nil.)</p> 
<pre class="brush: ruby">def do_update_item(key_id, update_exp, condition_exp, exp_attribute_values)
  begin
    old_result = @dynamodb.update_item(
      :update_expression =&gt; update_exp,
      :condition_expression =&gt; condition_exp,
      :expression_attribute_values =&gt; exp_attribute_values,
      :table_name =&gt; &quot;ProductCatalog&quot;,
      :key =&gt; { :Id =&gt; key_id },
      :return_values =&gt; &quot;ALL_OLD&quot;,
    ).data.attributes
  rescue Aws::DynamoDB::Errors::ConditionalCheckFailedException
    old_result = nil
    puts &quot;Condition not met&quot;
  end

  new_result = @dynamodb.get_item(
    :table_name =&gt; &quot;ProductCatalog&quot;, :key =&gt; { :Id =&gt; key_id },
    :consistent_read =&gt; true
  ).data.item  

  return old_result, new_result
end
</pre> 
<h2>Using Conditional Update Expressions</h2> 
<p>Updates in DynamoDB are atomic. This allows applications to concurrently update items without worrying about conflicts occurring. For example, the following code demonstrates maintaining a MAX value in DynamoDB with a conditional update using SET. Note that, because DynamoDB is schema-less, we don’t need to define the HighestRating attribute beforehand. Instead, we create it on the first call.</p> 
<pre class="brush: ruby"># storing a &quot;max&quot; value with conditional SET
# SET attribute if doesn't exist, otherwise SET if stored highest rating &lt; this rating
def update_highest_rating(rating)
  do_update_item(303,
    &quot;SET HighestRating = :val&quot;,
    &quot;attribute_not_exists(HighestRating) OR HighestRating &lt; :val&quot;,
    {
      &quot;:val&quot; =&gt; rating
    }
  )
end

# multiple threads trying to SET highest value (ranging from 0 to 10)
threads = []
(0..10).to_a.shuffle.each { |i|
  # some number of &quot;Condition not met&quot; depending on shuffled order
  puts i
  threads[i] = Thread.new {
    update_highest_rating(i)
  }
}
threads.each {|t| t.join}

# fetch the item and examine the HighestRating stored
puts &quot;Max = #{@dynamodb.get_item(
  :table_name =&gt; &quot;ProductCatalog&quot;, :key =&gt; { :Id =&gt; 303 }
).data.item[&quot;HighestRating&quot;].to_i}&quot;   # Max = 10
</pre> 
<p>We can also use update expressions to atomically maintain a count and add to a set:</p> 
<pre class="brush: ruby"># ADD to intialize/increment and add to set
threads = []
20.times do |i|
  threads[i] = Thread.new {
    do_update_item(303,
      &quot;ADD TimesViewed :val, Tags :was_here&quot;,
      nil, # no condition expression
      {
        # Each of the 20 threads increments by 1
        &quot;:val&quot; =&gt; 1,

        # Each thread adds to the tag set
        # Note: type must match stored attribute's type
        &quot;:was_here&quot; =&gt; Set.new([&quot;#Thread#{i}WasHere&quot;])
      }
    )
  }
end
threads.each {|t| t.join}

# fetch the item and examine the TimesViewed attribute
item = @dynamodb.get_item(
  :table_name =&gt; &quot;ProductCatalog&quot;, :key =&gt; { :Id =&gt; 303 }
).data.item

puts &quot;TimesViewed = #{item[&quot;TimesViewed&quot;].to_i}&quot;
# TimesViewed = 20

puts &quot;Tags = #{item[&quot;Tags&quot;].inspect}&quot;
# Tags = #&lt;Set: {&quot;#Mars&quot;, &quot;#MarsCuriosity&quot;, &quot;#StillRoving&quot;, ..each thread was here...}&gt;
</pre> 
<p>Similarly, we can decrement the count and remove from the set to undo our previous operations.</p> 
<pre class="brush: ruby"># Undo the views and set adding that we just performed
threads = []
20.times do |i|
  threads[i] = Thread.new {
    do_update_item(303,
      &quot;ADD TimesViewed :val DELETE Tags :was_here&quot;,
      nil,  # no condition expression
      {
        # Each of the 20 threads decrements by 1
        &quot;:val&quot; =&gt; -1,

        # Each thread removes from the tag set
        # Note: type must match stored attribute's type
        &quot;:was_here&quot; =&gt; Set.new([&quot;#Thread#{i}WasHere&quot;])
      }
    )
  }
end
threads.each {|t| t.join}

# fetch the item and examine the TimesViewed attribute
item = @dynamodb.get_item(
  :table_name =&gt; &quot;ProductCatalog&quot;, :key =&gt; { :Id =&gt; 303 }
).data.item

puts &quot;TimesViewed = #{item[&quot;TimesViewed&quot;].to_i}&quot;
# TimesViewed = 0

puts &quot;Tags = #{item[&quot;Tags&quot;].inspect}&quot;
# Tags = #&lt;Set: {&quot;#Mars&quot;, &quot;#MarsCuriosity&quot;, &quot;#StillRoving&quot;}&gt;
</pre> 
<p>We can also use the REMOVE keyword to delete attributes, such as the HighestRating and TimesViewed attributes we added in the previous code.</p> 
<pre class="brush: ruby"># removing attributes from items
old_and_new = do_update_item(303,
  &quot;REMOVE HighestRating, TimesViewed&quot;,
  nil,  # no condition expression
  nil,  # no attribute expression values
)

puts &quot;OLD HighestRating is nil ? #{old_and_new[0][&quot;HighestRating&quot;] == nil}&quot;
#=&gt; false

puts &quot;OLD TimesViewed is nil ? #{old_and_new[0][&quot;TimesViewed&quot;] == nil}&quot;
#=&gt; false

puts &quot;NEW HighestRating is nil ? #{old_and_new[1][&quot;HighestRating&quot;] == nil}&quot;
#=&gt; true

puts &quot;NEW TimesViewed is nil ? #{old_and_new[1][&quot;TimesViewed&quot;] == nil}&quot;
#=&gt; true
</pre> 
<h2>Conclusion</h2> 
<p>We hope this series was helpful in demonstrating expressions and how they allow you to interact with DynamoDB more flexibly than before. We’re always interested in hearing what developers would like to see in the future, so let us know what you think in the comments or through our <a href="https://forums.aws.amazon.com/forum.jspa?forumID=131">forums</a>!</p>