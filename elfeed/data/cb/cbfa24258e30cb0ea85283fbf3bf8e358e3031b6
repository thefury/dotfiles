<p><a href="https://aws.amazon.com/documentation/secretsmanager" rel="noopener noreferrer" target="_blank">AWS Secrets Manager</a> now has a <a href="https://github.com/aws/aws-secretsmanager-caching-net" rel="noopener noreferrer" target="_blank">client-side caching library for.NET</a> that makes it easier to access secrets from .NET applications. This is in addition to <a href="https://aws.amazon.com/blogs/security/use-aws-secrets-manager-client-side-caching-libraries-to-improve-the-availability-and-latency-of-using-your-secrets/" rel="noopener noreferrer" target="_blank">client-side caching libraries for Java, JDBC</a>, <a href="https://github.com/aws/aws-secretsmanager-caching-python" rel="noopener noreferrer" target="_blank">Python</a>, and <a href="https://github.com/aws/aws-secretsmanager-caching-go" rel="noopener noreferrer" target="_blank">Go</a>. These libraries help you improve availability, reduce latency, and reduce the cost of retrieving your secrets. Secrets Manager cache library does this by serving secrets out of a local cache and eliminating frequent Secrets Manager API calls.</p> 
<p>AWS Secrets Manager enables you to automatically rotate, manage, and retrieve secrets throughout their lifecycle. Users and applications can access secrets through a call to Secrets Manager APIs, eliminating the need to hardcode sensitive information in plain text. It offers secret rotation with built-in integration for AWS services such as <a href="http://aws.amazon.com/rds" rel="noopener noreferrer" target="_blank">Amazon Relational Database Service</a> (Amazon RDS) and Amazon Redshift, and it’s also extensible to other types of secrets. Secrets Manager enables you to control access to secrets using fine-grained permissions, and all actions on secrets, including retrievals, are traceable and auditable through <a href="http://aws.amazon.com/cloudtrail" rel="noopener noreferrer" target="_blank">AWS CloudTrail</a>.</p> 
<p>AWS Secrets Manager client-side caching for .NET extends benefits of the AWS Secrets Manager to wider use cases in .NET applications. These extra benefits are now available without having to spend precious time and effort on developing your own caching solution.</p> 
<p>In this post, I’ll discuss the following topics:</p> 
<ul> 
 <li>The benefits offered by Secrets Manager client-side caching library for .NET</li> 
 <li>How Secrets Manager client-side caching library for .NET works</li> 
 <li>How to use Secrets Manager client-side library in .NET applications</li> 
 <li>How to extend Secrets Manager client-side library with your own custom logic</li> 
</ul> 
<h2>The benefits offered by Secrets Manager client-side caching library for .NET</h2> 
<p>Client-side caching is benefitial in following ways:</p> 
<ul> 
 <li><b>Availability</b>: Network links sometimes suffer slowdowns or intermittent breaks. Client-side caching can significantly improve availability by eliminating a large number of API calls.</li> 
 <li><b>Latency</b>: Retrieving secrets through API calls includes the network latency. Retrieving secrets from the local cache eliminates that latency and, therefore, improves performance.</li> 
 <li><b>Cost</b>: Each API call to a Secrets Manager endpoint encounters a small charge. Using a local cache saves costs associated with API calls.</li> 
</ul> 
<p>Using a client-side cache is a best practice; however, in the same way that you don’t want to reinvent the wheel everytime you need one, crafting your own client-side caching solution is suboptimal. The Secrets Manager client-side caching library relieves you from writing your own client-side caching solution while still giving you its benefits. Furthermore, it includes best practices such as:</p> 
<ul> 
 <li>Automatically refreshing cached secrets: the library periodically updates secrets to ensure your application gets the most recent version of a secret. You can control and change refresh intervals using configuration properties.</li> 
 <li>Integration with your applications: To use this library, just add the dependency to your .NET project and provide the identifier to the secret you want to access in your code.</li> 
</ul> 
<h2>How Secrets Manager client-side caching library for .NET works</h2> 
<p>The library is implemented in .NET Standard. This means you can reuse the same library in projects of all flavors of .NET, including .NET Framework, .NET Core, and Xamarin. </p> 
<blockquote>
 <p><strong>Note:</strong> Because the AWS Secrets Manager client-side caching library depends on Microsoft.Extensions.caching.memory, make sure you add it to your project dependencies.</p>
</blockquote> 
<p>As an extension to Secrets Manager .NET SDK, the cache library provides you an alternative to direct invocation of Secrets Manager API methods. You invoke cache library methods, and if the value doesn’t exist in the cache, the cache library invokes Secrets Manager methods on your behalf.</p> 
<p>The default refresh interval for “current” version of secrets (the latest value stored in Secrets Manager for that secret) is 1 hour. This is because latest version may change from time to time. The library allows you to configure this frequency to higher or lower per your specific application requirements.</p> 
<p>If you request a specific version of a secret by specifying both secret ID and secret version parameters, by default the library sets refresh interval to 48 hours. Since each version of a secret is immutable, there is no need to refresh them frequently.</p> 
<p>You can also enable “Last known good value caching” to provide some protection in cases of transient network issues or service outages. If this is enabled, the cache will keep track of the last known good secret value, and in the event of an error occurring while refreshing a secret value from the service, the cache will return the last known good value. This feature is disabled by default, and can be enabled by setting the <span style="font-family: courier">EnableLastKnownGoodValueCaching</span> property of <span style="font-family: courier">SecretsManagerCacheOptions</span> class to <span style="font-family: courier">true</span>. You can pass your instance of <span style="font-family: courier">SecretsManagerCacheOptions</span> to <span style="font-family: courier">SecretsManagerCache</span> constructor.</p> 
<p>The cache library provides a thread-safe implementation for both cache-check as well as entry populations. Therefore, simultaneous requests for a secret that is not available in the cache will result in a single API request to SecretsManager.</p> 
<h2>How to use Secrets Manager client-side caching library in .NET applications</h2> 
<p>You can add Secrets Manager client-side caching library to your projects either directly or through dependency injection. The dependency package is also available through <a href="https://www.nuget.org/packages/AWSSDK.SecretsManager.Caching/" rel="noopener noreferrer" target="_blank">NuGet</a>. In this example, I use NuGet to add the library to my project. Open the <strong>NuGet Package Manager</strong> console and browse for <strong>AWSSDK.SecretsManager.Caching</strong>. Select the library and install it.<br /> &nbsp;<br /> </p>
<div id="attachment_10697" style="width: 760px" class="wp-caption aligncenter">
 <img src="https://d2908q01vomqb2.cloudfront.net/22d200f8670dbdb3e253a90eee5098477c95c23d/2019/05/23/fig1-SecretsManager-ClientSideCache-DotNet-0.7.png" alt="Figure 1: Select the AWSSDK.SecretsManager.Caching library" width="750" height="556" class="size-full wp-image-10697" />
 <p class="wp-caption-text">Figure 1: Select the AWSSDK.SecretsManager.Caching library</p>
</div>
<p></p> 
<p>Before using the cache, you need to have at least one secret stored in your account using AWS Secrets Manager. To create a test secret:</p> 
<ol> 
 <li>Go to the <b>AWS Console</b>, and then select <b>AWS Secrets Manager</b>.</li> 
 <li>Select <b>Store a new secret</b>. </li> 
 <li>For secret type, select <b>Other type of secret</b>, and then add three key/value pairs as shown here: 
  <div class="hide-language"> 
   <pre><code class="lang-text">
    {
      &quot;Domain&quot;: &quot;<span style="color: #ff0000"><i>&lt;yourDomainName&gt;</i></span>&quot;,
      &quot;UserName&quot;: &quot;<span style="color: #ff0000"><i>&lt;yourUserName&gt;</i></span>&quot;,
      &quot;Password&quot;: &quot;<span style="color: #ff0000"><i>&lt;yourPassword&gt;</i></span>&quot;
    }  
    </code></pre> 
   <p></p>
  </div> </li> 
 <li>Next, create a cache object, and then invoke its methods with appropriate parameters. Below is a code snippet using AWS Secrets Manager client-side cache library to access our secret. Notice this snippet assumes you’ve added Newtonsoft.Json library to your project: 
  <div class="hide-language"> 
   <pre><code class="lang-text">
    <span style="color: #0000FF">public</span> MyClass : IDisposable
    {
            <span style="color: #0000FF">private readonly</span> IAmazonSecretsManager secretsManager;
            <span style="color: #0000FF">private readonly</span> ISecretsManagerCache cache;
        
            <span style="color: #0000FF">public</span> MyClass()
            {
                <span style="color: #0000FF">this</span>.secretsManager = <span style="color: #0000FF">new</span> AmazonSecretsManagerClient();
                <span style="color: #0000FF">this</span>.cache = <span style="color: #0000FF">new</span> SecretsManagerCache(<span style="color: #0000FF">this</span>.secretsManager);
            }
    
            <span style="color: #0000FF">public void</span> Dispose()
            {
                <span style="color: #0000FF">this</span>.secretsManager.Dispose();
                <span style="color: #0000FF">this</span>.cache.Dispose();
            }
        
            <span style="color: #0000FF">public async</span> Task&lt;NetworkCredential&gt; GetNetworkCredential(<span style="color: #0000FF">string</span> secretId)
                {
                    <span style="color: #0000FF">var</span> sec = <span style="color: #0000FF">await this</span>.cache.GetSecretAsync(secretId);
                    <span style="color: #0000FF">var</span> jo = Newtonsoft.Json.Linq.JObject.Parse(sec.SecretString);
                    <span style="color: #0000FF">return new</span> NetworkCredential(
                        domain: jo[&quot;<span style="color: #ff0000"><i>Domain</i></span>&quot;].ToObject&lt;<span style="color: #0000FF">string</span>&gt;(),
                        userName: jo[&quot;<span style="color: #ff0000"><i>Username</i></span>&quot;].ToObject&lt;<span style="color: #0000FF">string</span>&gt;(),
                        password: jojo[&quot;<span style="color: #ff0000"><i>Password</i></span>&quot;].ToObject&lt;<span style="color: #0000FF">string</span>&gt;());
                }
            }        
    </code></pre> 
   <p></p>
  </div> </li> 
</ol> 
<p>For ASP.NET projects, you can use the library with dependency-injection. To do this, you first have to register Secrets Manager caching to the dependency injection service collection in the Startup class of your ASP.NET project:</p> 
<div class="hide-language"> 
 <pre><code class="lang-text">
<span style="color: #0000FF">public class</span> <span style="color: #008080">Startup</span>
{
    <span style="color: #0000FF">public void</span> ConfigureServices(IServiceCollection services)
    {
        services.AddSecretsManagerCaching();
    }
}
</code></pre> 
</div> 
<p>Then, you’ll be able to consume the cache using constructor injection in your classes.</p> 
<div class="hide-language"> 
 <pre><code class="lang-text">
<span style="color: #0000FF">public</span> MyClass : IDisposable
    {
        <span style="color: #0000FF">private readonly</span> ISecretsManagerCache cache;

        <span style="color: #0000FF">public</span> MyClass(ISecretsManagerCache cache)
        {
            <span style="color: #0000FF">this</span>.cache = cache;
        }

        <span style="color: #0000FF">public async</span> Task&lt;NetworkCredential&gt; GetNetworkCredential(<span style="color: #0000FF">string</span> secretId)
        {
            <span style="color: #0000FF">var</span> sec = <span style="color: #0000FF">await this</span>.cache.GetSecretAsync(secretId);
            <span style="color: #0000FF">var</span> jo = Newtonsoft.Json.Linq.JObject.Parse(sec.SecretString);
                        <span style="color: #0000FF">return new</span> NetworkCredential(
                        domain: jo[&quot;<span style="color: #ff0000"><i>Domain</i></span>&quot;].ToObject&lt;<span style="color: #0000FF">string</span>&gt;(),
                        userName: jo[&quot;<span style="color: #ff0000"><i>Username</i></span>&quot;].ToObject&lt;<span style="color: #0000FF">string</span>&gt;(),
                        password: jojo[&quot;<span style="color: #ff0000"><i>Password</i></span>&quot;].ToObject&lt;<span style="color: #0000FF">string</span>&gt;());
        }
    }    
</code></pre> 
</div> 
<h2>How to add in-memory encryption and other custom extensions</h2> 
<p>The Secrets Manager caching library is designed to be extendable with your own custom logic. One possibility is to extend its implementation to include in-memory encryption of cached secrets to add another layer of protection on your retrieved secrets. For this purpose, you have to manually implement two of the interfaces included in the library. The library includes <span style="font-family: courier">SecretCacheEntry</span> class, implementing the interface <span style="font-family: courier">ISecretCacheEntry</span>. This is the object that stores secrets in memory. You could create another class implementing the same <span style="font-family: courier">ISecretCacheEntry</span> interface to add in-memory encryption/decryption. </p> 
<div class="hide-language"> 
 <pre><code class="lang-text">
<span style="color: #0000FF">public class</span> <span style="color: #008080">EncryptedSecretCacheEntry</span> : ISecretCacheEntry
    {
        <span style="color: #0000FF">public</span> EncryptedSecretCacheEntry(GetSecretValueResponse response, TimeSpan expiry)
        {
            <span style="color: #0000FF">this</span>.VersionId = response.VersionId;
            <span style="color: #0000FF">this</span>.LastRetreived = DateTime.UtcNow;
            <span style="color: #0000FF">this</span>.Name = response.Name;
            <span style="color: #0000FF">this</span>.Expires = <span style="color: #0000FF">this</span>.LastRetreived.Add(expiry);

            <span style="color: #0000FF">if</span> (response.SecretBinary != <span style="color: #0000FF">null</span> &amp;&amp; response.SecretBinary.Length &gt; 0)
            {
                <span style="color: #0000FF">using</span> (<span style="color: #0000FF">var</span> ms = response.SecretBinary)
                {
                    <span style="color: #0000FF">this</span>.SecretBinary = ms.ToArray();
                }
            }
            <span style="color: #0000FF">else</span>
            {
                <span style="color: #0000FF">this</span>.SecretString = response.SecretString; 
            }
        }
    
        <span style="color: #0000FF">private byte</span>[] _EncryptedSecretString;
        <span style="color: #0000FF">public string</span> SecretString
        {
            <span style="color: #0000FF">get</span> { <span style="color: #0000FF">return</span> MyCustomCipherService.DecryptString(_EncryptedSecretString); }
            <span style="color: #0000FF">set</span> { _EncryptedSecretString = MyCustomCipherService.EncryptString(value); }
        }
    
        <span style="color: #0000FF">private byte</span>[] _EncryptedSecretBinary;
        <span style="color: #0000FF">public byte</span>[] SecretBinary
        {
            <span style="color: #0000FF">get</span> { <span style="color: #0000FF">return</span> MyCustomCipherService.Decrypt(_EncryptedSecretBinary); }
            <span style="color: #0000FF">set</span> { _EncryptedSecretBinary = MyCustomCipherService.Encrypt(value); }
        }
    
        <span style="color: #0000FF">public string</span> VersionId { <span style="color: #0000FF">get</span>; <span style="color: #0000FF">private set</span>; }

        <span style="color: #0000FF">public string</span> Name { <span style="color: #0000FF">get</span>; <span style="color: #0000FF">private set</span>; }

        <span style="color: #0000FF">public string</span> LocalId =&gt; <span style="color: #8a3324">$&quot;</span>{<span style="color: #0000FF">this</span>.Name}<span style="color: #8a3324">:</span>{<span style="color: #0000FF">this</span>.VersionId}<span style="color: #8a3324">&quot;</span>;

        <span style="color: #0000FF">public</span> DateTime LastRetreived { <span style="color: #0000FF">get</span>; <span style="color: #0000FF">private set</span>; }

        <span style="color: #0000FF">public</span> DateTime Expires { <span style="color: #0000FF">get</span>; <span style="color: #0000FF">private set</span>; }
    } 
</code></pre> 
</div> 
<p>The second step is to implement the <span style="font-family: courier">ISecretCacheEntryFactory</span> class: </p> 
<div class="hide-language"> 
 <pre><code class="lang-text">
<span style="color: #0000FF">public class</span> <span style="color: #008080">EncryptedSecretCacheEntryFactory</span> : ISecretCacheEntryFactory
    {
        <span style="color: #0000FF">public</span> ISecretCacheEntry CreateEntry(GetSecretValueResponse response, TimeSpan expiry)
        {
            <span style="color: #0000FF">return new</span> EncryptedSecretCacheEntry(response, expiry);
        }
    }
</code></pre> 
</div> 
<p>Having these two classes, I can now modify the constructor of my <span style="font-family: courier">SecretsUserClass</span> to add my custom encryption logic to Secrets Manager cache library:</p> 
<div class="hide-language"> 
 <pre><code class="lang-text">
<span style="color: #0000FF">public</span> SecretsUserClass()
    {
        <span style="color: #0000FF">this</span>.secretsManager = <span style="color: #0000FF">new</span> AmazonSecretsManagerClient();
        <span style="color: #0000FF">this</span>.cache = <span style="color: #0000FF">new</span> SecretsManagerCache(<span style="color: #0000FF">this</span>.secretsManager, <span style="color: #0000FF">new</span>   EncryptedSecretCacheEntryFactory(), <span style="color: #0000FF">new</span> SecretsManagerCacheOptions(), <span style="color: #0000FF">null</span>);
    }
</code></pre> 
</div> 
<p>You could even go further and fully customize the cache by implementing <span style="font-family: courier">ISecretsManagerCache</span> or implementing a child class that inherits functionality of <span style="font-family: courier">SecretsManagerCache</span> and adds new methods to it. </p> 
<h2>Conclusion</h2> 
<p>It’s critical for enterprises to protect secrets from unauthorized access and adhere to various industry or legislative compliance requirements. Mitigating the risk of compromise often involves complex techniques, significant effort, and costs, such as applying encryption, managing vaults and HSM modules, rotating secrets, audit access, and so on. Because the level of effort is high, many developers tend to use the much simpler, but substantially riskier, alternative of hard-coding secrets in application code, or simply storing secrets in plain-text format. These practices are problematic from the security and compliance point of view, but they need to be understood as symptoms of the more fundamental problem of complexity in the systems enterprises have built. To address the problem of weak security and compliance practices, you have to address the problem of complexity. Complex systems can be simplified and made more secure when they are reusable, accessible, and are automated, needing no human interaction.</p> 
<p>In this post, I’ve shown how you can improve availability, reduce latency, and reduce the cost of using your secrets by using the Secrets Manager client-side caching library for .NET. I also showed how to extend it by implementing your own custom logic for more advanced use-cases, such as in-memory encryption of secrets. </p> 
<p>To get started managing secrets, open the <a href="https://console.aws.amazon.com/secretsmanager/home?region=us-east-1#/home" rel="noopener noreferrer" target="_blank">Secrets Manager console</a>. To learn more, read<br /> <a href="https://aws.amazon.com/blogs/aws/aws-secrets-manager-store-distribute-and-rotate-credentials-securely/" rel="noopener noreferrer" target="_blank">How to Store, Distribute, and Rotate Credentials Securely with Secret Manager</a> or refer to the <a href="https://aws.amazon.com/documentation/secretsmanager/" rel="noopener noreferrer" target="_blank">Secrets Manager documentation</a>. See <a href="https://aws.amazon.com/about-aws/global-infrastructure/regional-product-services/" rel="noopener noreferrer" target="_blank">AWS Region Table</a> for the list of AWS regions where Secrets Manager is available.</p> 
<p>If you have feedback about this blog post, submit comments in the Comments section below. If you have questions about this blog post, start a new thread in the <a href="https://forums.aws.amazon.com/forum.jspa?forumID=296" rel="noopener noreferrer" target="_blank">Secrets Manager forum</a>.</p> 
<p><strong>Want more AWS Security how-to content, news, and feature announcements? Follow us on <a href="https://twitter.com/AWSsecurityinfo" title="Twitter" target="_blank" rel="noopener noreferrer">Twitter</a>.</strong></p> 
<footer> 
 <div class="blog-author-box"> 
  <div class="blog-author-image"> 
   <img src="https://d2908q01vomqb2.cloudfront.net/22d200f8670dbdb3e253a90eee5098477c95c23d/2019/01/16/sepehr-samiei-author-bio.jpg" alt="" width="119" height="160" class="aligncenter size-full wp-image-9773" /> 
  </div> 
  <h3 class="lb-h4">Sepehr Samiei</h3> 
  <p>Sepehr is currently a Senior Solutions Architect at AWS. He started his professional career as a .Net developer, which continued for more than 10 years. Early on, he quickly became a fan of cloud computing and loves to help customers utilise the power of Microsoft tech on AWS. His wife and daughter are the most precious parts of his life, and he and his wife expect to have a son soon!</p> 
  <p></p>
 </div> 
</footer>