<h1 id="introducing-transaction-support-in-aws-record">Introducing Transaction Support in aws-record</h1> 
<p>The <a href="https://github.com/aws/aws-sdk-ruby-record">aws-record Ruby Gem</a> is a data mapper abstraction layer over <a href="https://aws.amazon.com/dynamodb/">Amazon DynamoDB</a>, a key-value and document database that delivers single-digit millisecond performance at any scale.</p> 
<p>Recently, support for <a href="https://aws.amazon.com/blogs/aws/new-amazon-dynamodb-transactions/">transactions</a> was added to DynamoDB. DynamoDB transactions simplify the developer experience of making coordinated, all-or-nothing changes to multiple items both within and across tables. Transactions provide atomicity, consistency, isolation, and durability (ACID) in DynamoDB, enabling you to maintain data correctness in your applications easily.</p> 
<p>Today, we’re launching support for DynamoDB transactional find and write operations directly from <code>aws-record</code>. This support enables you to enjoy the benefits of transactional operations, while also getting to use the object abstractions that <code>aws-record</code> provides.</p> 
<h2 id="how-to-use-dynamodb-transactions-by-example">How to use DynamoDB transactions by example</h2> 
<p>Let’s assume we have two tables for a game where players can buy items with virtual coins (much like Danilo’s example from the announcement post). In <code>aws-record</code>, you might model the two tables this way.</p> 
<pre class="unlimited-height-code"><code class="lang-ruby">class GameItem
  include Aws::Record
  string_attr  :id, hash_key: true
  string_attr  :name
  integer_attr :price
  integer_attr :update_serial, default_value: 1
  string_attr :owned_by
end

class GamePlayer
  include Aws::Record
  string_attr  :id, hash_key: true
  integer_attr :coins
  list_attr    :items, default_value: []
  boolean_attr :active
  integer_attr :update_serial, default_value: 1
end</code></pre> 
<p>Although we could potentially <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/bp-modeling-nosql-B.html">design this as a single table</a>, the fact that this example uses two tables also helps us demonstrate that transaction support can span multiple DynamoDB tables in a single transaction.</p> 
<h2 id="transactional-finds">Transactional finds</h2> 
<p>The <code>aws-record</code> gem provides two approaches to perform transactional finds:</p> 
<ul> 
 <li>The <code>Aws::Record::Transactions.transact_find</code> operation, which allows you to create transactional finds that span multiple tables, but automatically marshal the response into an array of <code>aws-record</code> item objects of the appropriate model class.</li> 
 <li>Calling the <code>.transact_find</code> operation directly on an aws-record model class. This is useful when your find transaction does not span multiple tables, and allows your code to be more concise.</li> 
</ul> 
<p>Let’s take a look at two side-by-side examples using the tables we defined above. First, let’s get a set of items using find operations directly on the different tables.</p> 
<pre class="unlimited-height-code"><code class="lang-ruby">items = GameItem.transact_find(
  transact_items: [
    { key: { id: 'item-1-id' }},
    { key: { id: 'item-id-not-found' }},
    { key: { id: 'item-2-id' }}
  ]
).responses
items.map { |i| i.class } # =&gt; [GameItem, NilClass, GameItem]

players = GamePlayer.transact_find(
  transact_items: [
    { key: { id: 'player-1-id' }},
    { key: { id: 'player-2-id' }}
  ]
).responses
players.map { |i| i.class } # =&gt; [GamePlayer, GamePlayer]</code></pre> 
<p>The <a href="https://docs.aws.amazon.com/awssdkrubyrecord/api/Aws/Record/ItemOperations/ItemOperationsClassMethods.html#transact_find-instance_method">model-level transactional find API</a> expects a hash including a <code>:key</code> sub-hash that includes the key to be retrieved for the given item. (You can also optionally provide extra parameters to include in the request, such as a projection expression.)</p> 
<p>You can see that the <code>responses</code> array contains <code>aws-record</code> items, but can also contain <code>nil</code> when an item in your transaction isn’t found.</p> 
<p>How would we do the same thing in a single transactional find call? That’s where the global variant comes in handy.</p> 
<pre class="unlimited-height-code"><code class="lang-ruby">objects = Aws::Record::Transactions.transact_find(
  transact_items: [
    GameItem.tfind_opts(key: { id: 'item-1-id' }),
    GameItem.tfind_opts(key: { id: 'item-id-not-found' }),
    GameItem.tfind_opts(key: { id: 'item-2-id' }),
    GamePlayer.tfind_opts(key: { id: 'player-1-id' }),
    GamePlayer.tfind_opts(key: { id: 'player-2-id' })
  ]
).responses
objects.map { |i| i.class } # =&gt; [GameItem, NilClass, GameItem, GamePlayer, GamePlayer]</code></pre> 
<p>The <a href="https://docs.aws.amazon.com/awssdkrubyrecord/api/Aws/Record/Transactions.html#transact_find-class_method">top-level transactional find API</a> involves writing a bit more code, but enables you to mix and match different tables and models in a single batch of finds.</p> 
<h2 id="transactional-writes">Transactional writes</h2> 
<p>The <a href="https://docs.aws.amazon.com/awssdkrubyrecord/api/Aws/Record/Transactions.html#transact_write-class_method">transactional write API</a> provides a way to pass in <code>aws-record</code> items into transactional writes. It also adds the ability to run “save” commands in a transaction, while allowing <code>aws-record</code> to determine if a <code>:put</code> or <code>:update</code> operation is most appropriate. Additionally, it ports the <code>aws-record</code> <code>#save</code> logic (performing a conditional put or an update, depending on what has changed in a given item) to the DynamoDB transactional operations.</p> 
<p>Let’s look at how we would perform some transactional writes to implement our game example. Let’s assume we want to take a player ID and an item ID from our game, and attempt to “buy” that item as that player.</p> 
<pre class="unlimited-height-code"><code class="lang-ruby">def buy_item(player_id, item_id)
  player, item = Aws::Record::Transactions.transact_find(
    transact_items: [
      GamePlayer.tfind_opts(key: { id: player_id }),
      GameItem.tfind_opts(key: { id: item_id })
    ]
  ).responses
  raise ArgumentError if player.nil? || item.nil?
  player.coins -= item.price
  item.available = false
  item.owned_by = player.id
  player.items &lt;&lt; item.id
  player.update_serial += 1
  item.update_serial += 1
  Aws::Record::Transactions.transact_write(
    transact_items: [
      {
        update: player,
        condition_expression: &quot;#COINS &gt;= :p AND #SERIAL = :s&quot;,
        expression_attribute_names: {
          '#COINS' =&gt; 'coins',
          '#SERIAL' =&gt; 'update_serial'
        },
        expression_attribute_values: {
          ':p' =&gt; (item.price),
          ':s' =&gt; (player.update_serial - 1)
        }
      },
      {
        update: item,
        condition_expression: &quot;#AVAIL = :true AND #SERIAL = :s&quot;,
        expression_attribute_names: {
          '#AVAIL' =&gt; 'available',
          '#SERIAL' =&gt; 'update_serial'
        },
        expression_attribute_values: {
          ':true' =&gt; true,
          ':s' =&gt; (item.update_serial - 1)
        }
      }
    ]
  )
end</code></pre> 
<p>Because transactional writes either all fail or all succeed, you can avoid race conditions where, for example, multiple players are recorded as owning the same item, or coin/item inventories don’t line up. This remains true even if you’re using multiple tables in your application.</p> 
<p>You can also add checks to your transactions. Imagine if we had a global <code>GameState</code> table, which we used, in part, to determine if any transactions were allowed. We could add a check expression, where an item is checked as a part of the transaction but not changed, like so:</p> 
<pre class="unlimited-height-code"><code class="lang-ruby">Aws::Record::Transactions.transact_write(
  transact_items: [
    {
      update: player,
      condition_expression: &quot;#COINS &gt;= :p AND #SERIAL = :s&quot;,
      expression_attribute_names: {
        '#COINS' =&gt; 'coins',
        '#SERIAL' =&gt; 'update_serial'
      },
      expression_attribute_values: {
        ':p' =&gt; (item.price),
        ':s' =&gt; (player.update_serial - 1)
      }
    },
    {
      update: item,
      condition_expression: &quot;#AVAIL = :true AND #SERIAL = :s&quot;,
      expression_attribute_names: {
        '#AVAIL' =&gt; 'available',
        '#SERIAL' =&gt; 'update_serial'
      },
      expression_attribute_values: {
        ':true' =&gt; true,
        ':s' =&gt; (item.update_serial - 1)
      }
    },
    {
      check: GameState.transact_check_expression(
        key: { config_set_id: &quot;GLOBAL&quot; },
        condition_expression: &quot;#A = :true&quot;,
        expression_attribute_names: {
          &quot;#A&quot; =&gt; &quot;purchases_active&quot;
        },
        expression_attribute_values: {
          &quot;:true&quot; =&gt; true
        }
      )
    }
  ]
)</code></pre> 
<p>This variant would also fail to complete the item purchase transaction if purchases were globally disabled for any reason, even if the player and item otherwise meet the transaction conditions.</p> 
<h2 id="conclusion">Conclusion</h2> 
<p>With this new feature in <code>aws-record</code> you can take advantage of the DynamoDB support for transactions, while continuing to represent your DynamoDB items as objects, and leveraging features like intelligent <code>save</code> behavior.</p> 
<p>What can we deliver next to make your experience of using DynamoDB in Ruby even easier? Let me know!</p>