<p>By Brent Rabowsky, Startup Solutions Architect, AWS</p><p>Welcome to the second post in this two-part series about building serverless architectures on AWS, with emphasis on using Java 8 together with AWS Lambda and Amazon DynamoDB. In the <a href="https://medium.com/aws-activate-startup-blog/serverless-architectures-with-java-8-aws-lambda-and-amazon-dynamodb-part-1-fde79a6fb3cf#.l2y7qitnt">first post</a> , I focused on data modeling with DynamoDB. Careful attention to data modeling before you start coding helps ensure that your back end service is architected for optimal performance.</p><p>In this post, I continue the discussion by presenting an implementation of a back end service to support the example use case of the first post. As you might recall, the use case involves a company that is building out a new API backed by DynamoDB to access a catalog of sports events.</p><h3>Using Java 8 with AWS Lambda</h3><p>For my implementation, I developed Lambda functions for the Lambda Java 8 runtime. The release of the Java 8 runtime for Lambda marked an important step in the evolution of the Lambda service. Many companies of all sizes, from startups to multinational enterprises, use JVM-based stacks in their products.</p><p>There are many reasons for this, including the ability to highly tune applications running on a JVM, access to extensive tooling for developing and working with JVM-based applications, and a vast supporting ecosystem that includes frameworks and libraries that enable developing JVM-based applications in just about any programming paradigm, from imperative to functional to reactive.</p><p>Although there are several possible ways to structure a Java 8 code base for Lambda, the code base for this post is structured as a single code base that combines multiple Lambda function handlers in a single source control repository. Combining handlers is useful for logically grouping together Lambda functions that jointly would be considered a microservice if developed with a traditional server-based approach, and deployed and run in a Java servlet container such as Tomcat or Jetty. Another rationale for the combined approach is the convenience of code and deployment management that results from managing one repository rather than many.</p><h3>Prerequisites and Setup</h3><p>The primary prerequisite for running the code for this example is to create an EVENT table in DynamoDB. Using the Amazon DynamoDB console at <a href="https://console.aws.amazon.com/dynamodb">https://console.aws.amazon.com/dynamodb</a> or the AWS CLI, create the table with the keys and indexes specified in Part 1 of this blog post series for the EVENT table. When creating sample data to populate the table, keep in mind that the Event POJO (discussed later in the post) also supports the following attributes in addition to those specified previously: eventId (Number), sport (String), country (String).</p><p>All of the code referenced in this blog post series can be found on GitHub at <a href="https://github.com/awslabs/lambda-java8-dynamodb">https://github.com/awslabs/lambda-java8-dynamodb</a>. After you create the DynamoDB table, clone the example code base using the git clone command. Then build it with <a href="https://maven.apache.org/">Maven</a> using the mvn package command (if you don’t have Maven installed already, you need to install it now). Upload the resulting JAR file via the AWS console or CLI to each Lambda function, with one Lambda function created per handler in the code base. Because there are six handlers, you should create six Lambda functions. For a quick walkthrough that shows you how to create a Lambda function if you haven’t done so before, see the <a href="https://docs.aws.amazon.com/lambda/latest/dg/getting-started-create-function.html">Getting Started guide</a>.</p><h3>Code Base Features</h3><p>The example code base demonstrates several features of the AWS SDK for Java. In connection with DynamoDB, one of the most important features of the SDK is the convenience provided by DynamoDBMapper, an object mapper for DynamoDB. Like an <a href="https://en.wikipedia.org/wiki/Object-relational_mapping">ORM</a> library such as Hibernate for relational databases, DynamoDBMapper enables developer-friendly, shorthand domain-object interactions with a DynamoDB table via simple methods, which can be used for CRUD operations instead of having to construct queries with “raw” long-form API calls.</p><p>More specifically, to use DynamoDBMapper, for each domain object that corresponds to a DynamoDB table, create a <a href="https://en.wikipedia.org/wiki/Plain_Old_Java_Object">POJO</a> that comprises fields and accessors. Annotations are included on the POJO’s fields or getters to indicate whether they are ordinary attributes, or hash or sort keys for the table itself or the table index. In the example code base, the relevant POJO is the Event class, as shown in the following code snippet:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/900/1*vMwZMXEjzRnl5eLL4wmXDw.png" /></figure><p>Given this POJO, you can perform CRUD operations for a particular Event object using simple methods. These methods will be of the following form: mapper.save(…), mapper.delete(…), mapper.load(…), etc., where mapper is the DynamoDBMapper object and the method arguments are the event object or team name and event date.</p><p>The DynamoDBMapper object and the DynamoDB client are embedded in a reusable DynamoDBManager singleton class. This manager was not created using any third-party frameworks. Although it is possible to use Spring or other dependency injection frameworks with Lambda functions, consider keeping Lambda functions as lightweight as possible. Java 8 itself has obviated the need in some cases for common external libraries, such as Joda-Time and libraries that provide the equivalents of the new language features in Java 8. The AWS SDK for Java also provides many helpful features, such as serialization of objects returned by Lambda functions, as will be seen shortly.</p><p>In keeping with good object-oriented design principles for persistence-related code, CRUD operations for the API are described in a <a href="https://en.wikipedia.org/wiki/Data_access_object">data access object</a> (DAO) interface, specifically, the EventDao interface. Business logic in the rest of the API can rely on this interface, which is implemented by the DynamoDBEventDao class with code specific to DynamoDB.</p><p>To trace through how an API call is implemented, start with any Lambda function handler method. In the EventFunctions class, which has one Lambda handler method per API call, the API call for fetching events by city is represented by the getEventsForCity method. As shown in the snippet below, this method simply validates the input and returns a list of events, which <a href="https://docs.aws.amazon.com/lambda/latest/dg/java-programming-model-req-resp.html">Lambda itself conveniently serializes into JSON</a> without requiring any effort on the developer’s part.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/898/1*pNE2QftPDY_3eQATCeTdkA.png" /></figure><p>Most of the real work of the API call is done by the DynamoDBEventDao class, as shown by the next code snippet:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/898/1*MNRSaUF_RkV0IEcvIqSzoA.png" /></figure><p>The specific CRUD method invoked, findEventsByCity, performs a query against a GSI based on city name, rather than querying the table itself. One point to keep in mind is that queries against a GSI cannot be strongly consistent, and this must be specified when making a GSI query. As a result, a GSI query <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GSI.html#GSI.Writes">might not return up-to-date data</a>. However, as noted in the code comment in the snippet, without use of the GSI, an inefficient full-table scan would be needed to gather the result set. Also, for the example use case of this blog post series, the risk of queries returning stale data is mitigated by the fact that the event catalog is not frequently updated during a day.</p><p>Another helpful feature of the AWS SDK for Java in relation to Lambda functions is its integration of the log4j logging library. Using the log4j library, you can enable logging at multiple levels — such as debug, info, and error — to pinpoint issues and provide analytics. Logs generated by log4j for Lambda functions are readily accessible for viewing by going to the Lambda console, selecting the Lambda function at issue, and choosing <strong>View Logs in CloudWatch</strong> under the <strong>Monitoring</strong> tab. For more information about the special features of the AWS SDK for Java as they relate to authoring Lambda functions, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/java-programming-model.html">Programming Model for Authoring Lambda Functions in Java</a> in the <em>AWS Lambda Developer Guide</em>.</p><h3>Conclusion</h3><p>Using Lambda together with DynamoDB, you can rapidly build an API backed by a robust and scalable data store without ever having to be concerned with deploying and managing servers. When you develop Lambda functions using the Java 8 runtime, you can leverage the powerful and vast Java ecosystem, as well as the convenient features of the AWS SDK for Java.</p><p>With respect to DynamoDB, this post just scratched the surface of the available SDK features, which include many features not discussed here. These other features include support for <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DynamoDBMapper.OptimisticLocking.html">optimistic locking with DynamoDBMapper</a>, and a separate <a href="https://github.com/awslabs/dynamodb-transactions">transactions library</a> that you can use to wrap related CRUD operations. Additionally, testing your DynamoDB-related code locally in your developer environment is made easy by <a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DynamoDBLocal.html">DynamoDB Local</a>, a local version of DynamoDB that can help you save on provisioned throughput, data storage, and data transfer fees when testing.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=95ebd852d366" width="1" height="1"><hr><p><a href="https://medium.com/aws-activate-startup-blog/serverless-architectures-with-java-8-aws-lambda-and-amazon-dynamodb-part-2-95ebd852d366">Serverless Architectures with Java 8, AWS Lambda, and Amazon DynamoDB — Part 2</a> was originally published in <a href="https://medium.com/aws-activate-startup-blog">AWS Startup Collection</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>