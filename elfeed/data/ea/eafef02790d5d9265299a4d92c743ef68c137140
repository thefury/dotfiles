<p>Thanks to Jose Ferraris and Flynn Bundy for this great post about how to validate AWS CodeCommit pull requests with AWS CodeBuild and AWS Lambda. Both are DevOps Consultants from the <a href="https://aws.amazon.com/professional-services/">AWS Professional Services</a>’ EMEA team.</p> 
<p>—</p> 
<p>You can help ensure a high level of code quality and avoid merging code that does not integrate with previous changes by testing proposed code changes in pull requests before they are allowed to be merged. In this blog post, we’ll show you how to set up this kind of validation using <a href="https://aws.amazon.com/codecommit/">AWS CodeCommit</a>, <a href="https://aws.amazon.com/codebuild/">AWS CodeBuild</a>, and <a href="https://aws.amazon.com/lambda/">AWS Lambda</a>. In addition, we’ll show you how to set up a pipeline to automatically build your tested, approved, and merged code changes using <a href="https://aws.amazon.com/codepipeline/">AWS CodePipeline</a>.</p> 
<p>When we talk with customers and partners, we find that they are in different stages in the adoption of DevOps methodologies such as Continuous Integration and Continuous Deployment (CI/CD). However, one of the main requirements we see is a strong emphasis on automation of delivering resources in a safe, secure, and repeatable manner. One of the fundamental principles of CI/CD is aimed at keeping everyone on the team in sync about changes happening in the codebase. With this in mind, it’s important to fail fast and fail early within a CI/CD workflow to ensure that potential issues are caught before making their way into production.</p> 
<p>To do this, we can use services such as AWS CodeBuild for running our tests, along with AWS CodeCommit to store our source code. One of the ways we can “fail fast” is to validate pull requests with tests to see how they will integrate with the current master branch of a repository when first opened in AWS CodeCommit. By running our tests against the proposed changes prior to merging them into the master branch, we can ensure a high level of quality early on, catch any potential issues, and boost the confidence of the developer in relation to their changes. In this way, you can start validating your pull requests in AWS CodeCommit by utilizing AWS Lambda and AWS CodeBuild to automatically trigger builds and tests of your development branches.</p> 
<p>We can also use services such as AWS CodePipeline for visualizing and creating our pipeline, and automatically building and deploying merged code that has met the validation bar for pull requests.</p> 
<p>The following diagram shows the workflow of a pull request. The AWS CodeCommit repository contains two branches, the master branch that contains approved code, and the development branch, where changes to the code are developed. In this workflow, a pull request is created with the new code in the development branch, which the developer wants to merge into the master branch. The creation of the pull request is an event detected by AWS CloudWatch. This event will start two separate actions:<br /> • It triggers an AWS Lambda function that will post an automated comment to the pull request that indicates a build to test the changes is about to begin.<br /> • It also triggers an AWS CodeBuild project that will build and validate those changes.</p> 
<p>When the build completes, AWS CloudWatch detects that event. Another AWS Lambda function posts an automated comment to the pull request with the results of the build and a link to the build logs. Based on this automated testing, the developer who opened the pull request can update the code to address any build failures, and then update the pull request with those changes. Those updates will be built, and the build results are then posted to the pull request as a comment.</p> 
<p><img class="alignnone size-full wp-image-2978" src="https://d2908q01vomqb2.cloudfront.net/7719a1c782a1ba91c031a682a0a2f8658209adbf/2019/02/11/diagram1-cc-build.png" alt="" width="720" height="405" /></p> 
<p>Let’s show how this works in a specific example project. This project has its own set of tasks defined in the <a href="https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html">build specification file</a> that will execute and validate this specific pull request. The buildspec.yml for our example AWS CloudFormation template contains the following code:</p> 
<pre><code class="lang-yaml">version: 0.2

phases:
  install:
    commands:
      - pip install cfn-lint
  build:
    commands:
      - cfn-lint --template ./template.yaml --regions $AWS_REGION
      - aws cloudformation validate-template --template-body file://$(pwd)/template.yaml
artifacts:
  files:
    - '*'</code></pre> 
<p>In this example we are installing <a href="https://github.com/awslabs/cfn-python-lint">cfn-lint</a>, which perform various checks against our template, we are also running the AWS CloudFormation <a href="https://docs.aws.amazon.com/cli/latest/reference/cloudformation/validate-template.html">validate-template</a> command via the AWS CLI.</p> 
<p>Once the code included in the pull request has been built, AWS CloudWatch detects the build complete event and passes along the outcome to a Lambda function that will update the specific commit with a comment that notifies the users of the results. It also includes a link to build logs in AWS CodeBuild. This process repeats any time the pull request is updated. For example, if an initial pull request was opened but failed the set of tests associated with the project, the developer might fix the code and make an update to the currently opened pull request. This will in turn trigger the function to run again and update the comments section with the test results.</p> 
<p>Testing and validating pull requests before they can be merged into production code is a common approach and a best practice when working with CI/CD. Once the pull request is approved and merged into the production branch, it is also a good CI/CD practice to automatically build, test, and deploy that code. This is why we’ve structured this into two different AWS CloudFormation stacks (both can be found in our <a href="https://github.com/aws-samples/aws-codecommit-pull-request-aws-codebuild">GitHub repository</a>). One contains a base layer template that contains the resources you would only need to create once, in this case the AWS Lambda functions that test and update pull requests. The second stack includes an example of a CI/CD pipeline defined in AWS CloudFormation that imports the resources from the base layer stack.</p> 
<p><img class="alignnone size-full wp-image-2979" src="https://d2908q01vomqb2.cloudfront.net/7719a1c782a1ba91c031a682a0a2f8658209adbf/2019/02/11/diagrams2-cc-build.png" alt="" width="720" height="405" /></p> 
<p>We start by creating our base layer, which creates the Lambda functions and sets up AWS IAM roles that the functions will use to interact with the various AWS services. Once this stack is in place, we can add one or more pipeline stacks which import some of the values from the base layer. The pipeline will automatically build any changes merged into the master branch of the repository. Once any pipeline stack is complete, we have an AWS CodeCommit repository, AWS CodeBuild project, and an AWS CodePipeline pipeline set up and ready for deployment.</p> 
<p>We can now push some code into our repository on the master branch to trigger a run-through of our pipeline.</p> 
<p>In this example we will use the following AWS CloudFormation template. This template creates a single Amazon S3 bucket. This template will be the artifact that we push through our CI/CD pipeline and deploy to our stages.</p> 
<pre><code class="lang-yaml">AWSTemplateFormatVersion: '2010-09-09'
Description: 'A sample CloudFormation template that we can use to validate in our pipeline'
Resources:
  S3Bucket:
    Type: 'AWS::S3::Bucket'</code></pre> 
<p>Once this code is tested and approved in a pull request, it will be merged into the production branch as part of the pull request approve and merge process. This will automatically start our pipeline in AWS CodePipeline, and will run through to the stages defined for it. For example:</p> 
<p><img class="alignnone size-full wp-image-2980" src="https://d2908q01vomqb2.cloudfront.net/7719a1c782a1ba91c031a682a0a2f8658209adbf/2019/02/11/pipeline.png" alt="" width="2096" height="1198" /></p> 
<p>Now we can make some changes to our code base in the development branch and open a pull request. First, edit the file to make a typo in our CloudFormation template so we can test the validation.</p> 
<pre><code class="lang-yaml">AWSTemplateFormatVersion: '2010-09-09'
Metadata: 
  License: Apache-2.0
Description: 'A sample CloudFormation template that we can use to validate in our pipeline'
Resources:
  S3Bucket:
    Type: 'AWS::S3::<strong>Bucket1</strong>'</code></pre> 
<p>Notice that we changed the S3 bucket to be AWS::S3::Bucket1. This doesn’t exist, so cfn-lint will return a failure when it attempts to validate the template.</p> 
<p>Now push this change into our development branch in the AWS CodeCommit repository and open the pull request against the production (master) branch.</p> 
<p><img class="alignnone size-full wp-image-2981" src="https://d2908q01vomqb2.cloudfront.net/7719a1c782a1ba91c031a682a0a2f8658209adbf/2019/02/11/pull-request-opened.png" alt="" width="1900" height="1140" /></p> 
<p>From there, navigate to the comments section of the pull request. You should see a status update that the pull request is currently building.</p> 
<p>Once the build is complete, you should see feedback on the outcome of the build and its results given to us as a comment.</p> 
<p><img class="alignnone size-full wp-image-2982" src="https://d2908q01vomqb2.cloudfront.net/7719a1c782a1ba91c031a682a0a2f8658209adbf/2019/02/11/pull-request-build-failed.png" alt="" width="2026" height="1176" /></p> 
<p>Choose the <em>Logs</em> link to view details about the failure. We can see that we were able to catch an error related to linting rules failing.</p> 
<p><img class="alignnone size-full wp-image-2983" src="https://d2908q01vomqb2.cloudfront.net/7719a1c782a1ba91c031a682a0a2f8658209adbf/2019/02/11/error-msg.png" alt="" width="2272" height="812" /></p> 
<p>We can remedy this and update our pull request with the updated code. Upon doing so, we can see another build has been kicked off by looking at the comments of the pull request. Once this has been completed we can confirm that our pull request has been validated as desired and our tests have passed.</p> 
<p><img class="alignnone size-full wp-image-2984" src="https://d2908q01vomqb2.cloudfront.net/7719a1c782a1ba91c031a682a0a2f8658209adbf/2019/02/11/pull-request-build-passed.png" alt="" width="2034" height="1178" /></p> 
<p>Once this pull request is approved and merged to master, this will start our pipeline in AWS CodePipeline, which will take this code change through the specified stages.</p> 
<p><strong>Conclusion</strong></p> 
<p>In this post, we showed you how to validate AWS CodeCommit pull requests with AWS CodeBuild and AWS Lambda. We hope that the information in this posts helps you get started implementing this for your own applications! If you have any feedback, please leave it in the&nbsp;Comments&nbsp;section below.</p> 
<p>&nbsp;</p>